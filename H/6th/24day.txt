24day

dns의 계층 구조
dns 이전 hosts라는 해당되는 호스트와 아이피를 매핑 해놓은 텍스트 파일이 있었다.
ip 기반이 아닌 이름 기반으로 목적지를 지정했었다.

도메인 주소로만 통신할 수 있나?    ->    엄밀하게 말하면 불가능하다.
hosts, dns 목적은 문자로된 주소를 아이피로 바꿔주는 것이고
아이피를 가지고 통신하기 때문에 아이피 목적지 주소가 필요하다.    = 주소로만 통신 할 수 없다라는 결론이 나온다.

dns 서버가 전체 인터넷에 서버를 알고 있지 않는다.
dns는 트리형태로 계층구조로 되어있고 분산이 되어있다.
dns hierarchy 구조이다. = 계층구조

맨 위에 정점에는
Root Domain이 있고 .으로 구분한다.
www.google.com. 에서 맨 뒤에 .이 생략이 되어있는데, .은 루트 도메인이다.
.은 Root Hint A~M 13개의 서버를 가지고 있다.

Top Level Domain (TLD)
일반적으로 우리가 알고 있는 탑 레벨 도메인
gTLD    com(naver, google),    net(daum),    org(wikipedia),    edu    /    일반 최상위 도메인

ccTLD    kr,    jp,    us,    it    ...       /    국가 코드 최상위 도메인

TLD(3rd level domain)    co,    korea..   

3rd까지 반드시 등록 되어야 하고 그 아래쪽은 우리가 만들 수 있다.
subdomain : 각 회사가 만들 수 있다.
hostname : www

10.56.1168.192.in-addr-arpa.

arpa :
in-addr
ip6

TLD에 도메인을 등록 시킨다.

Root domain 계층 구조이다.
TLD(top)               com                    net                    org                    edu                    kr                    jp                        us                    it        ...            arpa
SLD(2)             google, naver           daum             wikipedia                                       co, korea                                                                                   in-addr     ip6
TLD(3)                                                                                                                 korea
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
subdomain                              support storge                                                     busan      seoul
hostname           www                www      ftp                                                 www   main  www   ftp 

위와 같은 형식으로 계층 구조로 되어있다.
DNS 서버는 UDP 53번 포트를 사용한다.

컴퓨터에 DNS 서버가 지정 되어있다. 회사에서 사용하는 DNS를 제외하고 보통 ISP 에서 제공해준걸 사용한다.
회사 같은 경우는 자체적으로 구성 되어있는 DNS 서버가 있거나 ISP에서 제공해준걸 사용한다.

DNS서버랑 ISP는 관계가 없다. 요즘은 IT 회사에서 DNS를 제공해주는 회사도 있다 (구글 8.8.8.8, 8.8.4.4)

DNS 서버는 리소스 레코드란걸 가지고 있다.    (www x.x.x.x , ftp x.x.x.x 같은 예를 RR
아이피와 dns를 매칭 해놓은걸 리소스 레코드라고 한다.
모든 dns 서버는 리소스 레코드를 가지고있다.
dns 서버는 자신보다 하위에 있는 정보만 가지고 있다.
지구 상의 전체 호스트를 가지고 있는게 아니라 분산해서  갖고있다.

cache only dns :
isp가 제공해주는 dns 서버는 가지고 있는 리소스 레코드가 없다.
dns를 쓸 수 있도록 기능만 제공해주는거다.

클라이언트가 ~~~.com 이란 사이트에 접속하기 위해서 isp  dns에 접근하게 되면
isp dns는 루트서버에 com이 어디에 있는지 물어본다.
모든 dns 서버는 자신이 서버이면서 클라이언트이다. 다른 서버한테 물어보기 때문에
모든 시스템, 클라이언트들을 캐시를 가지고있다. dns 캐시
영구적으로 저장하지 않는다. ttl을 지정해서 준다.

isp에서 지정해놓은 dns는 캐시만 가지고 있다.
사람들이 많이 쓰는것은 캐시로 저장 되어있다.

dns 서버들은 모르면 root 도메인에게 물어본다.
dnsㅐ 서버는 자신이 필요한 정보만 가지고 있기 때문에 다른 정보를 알 수 없다.

재귀커리
클라이언트가 요청한걸 완전하게 응답이 돌아오는것

순환커리
isp 업체들은 자기가 모르는건 순환한다. (떠넘긴다)

응답에도 2가지가 있다.
권한이 있는 응답, 내가 직접 가지고 있는 리소스 레코드를 주는 것 (캐시는 해당사항이 없다)
내가 받은 리소스 레코드를 주는 걸 권한이 없는 응답이라고 한다.

구글 dns 서버만 권한이 있는 응답을 해줄 수 있었는데 지금은 응답을 안해준다.

host -v -t A www.google.com 8.8.8.8
퍼블릭 dns 주소이다. - 그게 뭔데? - cache only dns server
구글 리소스 레코드를 가지고 있는 서버가 아니다. 그래서 권한이 없는 응답이다.

내가 수동으로 권한이 있는 응답을 받아내려면?
host -v -t NS google.com 8.8.8.8

host -v -t A ns1.google.com 8.8.8.8

ns1.google.com []

host -v -t A www.google.com 216.238.32.10

.. 안된다.
클라이언트가 직접 쿼리를 보내는걸 금지한다.
왜 ?    -> 재귀 커리를 안 받도록 해야한다. 클라이언트가 보낸 재귀 커리들을 다 받으려면 dns 서버의 용량이 커야한다.
누가 얼마나 들어올지 모르니까. 그렇게 되면 기업 입장에선 감당이 안된다. 그래서 반복 쿼리, 순환 쿼리만 가능하도록 막아둔다.

재귀 커리를 안 받게 세팅도 해야한다. 순환 쿼리로 응답을 받을 수 있게 구성해야한다.
재귀 커리를 다 받아주게 되면 디도스 공격도 받기 쉬워진다.
tcp 방식에선 힘들지만 udp는 디도스 공격을 받기 딱 좋다. 방식 자체가 없고 단순하게 보내고 받기만 하는 형태이기 때문이다.
그래서 디도스 공격을 받게 되면 해당되는 프로토콜을 차단 시키기도 한다고함.

권한이 없는 응답 데이터는 정확한 데이터 라고 할 수 없다.
권한이 있는 응답은 일반 클라이언트 입장에서 받을 수 없지만 정확한 데이터라고 할 수 있다.

FQDN을 지리 했을 때 IP를 알려주는걸 정방향조회
A,   AAAA

PTR, reverse lookup (역방향조회)
회사 내부에서 구현하는 경우가 많지 인터넷 환경에서는 하지 않는다.

윈도우 같은 경우 ipconfig/displaydns 명령어를 사용하면 dns cache를 볼 수 있지만
유닉스는 dns cache를 볼 수 있는 명령어가 없다. 어플리케이션 자체에서 dns cache를 사용하기 때문이다.

윈도우는 인터넷 브라우저를 띄우면 운영체제 레벨에서 캐시를 관리하는데
유닉스는 어플리케이션 자체에서 캐시를 관리한다.

캐시를 관리하는 기법 자체가 다르다. 누구가 더 좋고 이런건 아니다.

SOA 권한의 시작.. 권한이 있는 응답과 똑같은 의미로 사용된다.

리눅스에서 사용하는 명령어 3가지
hosts, nslookup, dic
hosts는 리눅스 계열이면 무조건 있다고 보면 된다.
nslookup은 원래 윈도우 에서만 존재하는 명령어 였지만 유닉스 계열로 가지고 왔다. 하지만 잘 사용하지 않는다.
dic는 hosts와 다를게 없다.

Dns 소프트웨어
bind (오픈소스 / 거의 표준이다), nsd (오픈소스)

항상 패키지를 설치하면 설정파일을 확인 해야한다.    /    systemctl enable [명령어]

dns라는 프로토콜은 상당히 복잡한 매커니즘을 가지고 있다.
bind 원서가 따로 존재하는데 dns만 약 2000페이지가 있을 정도로 복잡하다.

#,    ;,    // vi에서 주석으로 사용한다.

directory는 /var/named 리소스 레코드
데이터 베이스는 기본적으로 /var/named에 있다.

allow-query  - 쿼리를 허용할 위치

영역 (zone)
하나의 도메인은 하나의 영역으로 만들어야한다.

named.conf 파일에 zone (영역)을 설정 해야한다.
a~m 서버의 정보가 들어있다.

자기가 모르는걸 루트 힌트 서버를 만들어야한다.
모든 dns 서버는 루트 힌트 서버 정보를 가지고 있어야한다.
패키지 설치 시 보통 기본적으로 존재한다.

dns 서버를 만들 때 일반적으로 도메인명.zone으로 만든다고 한다.    /    cccr.net.zone
/var/named/cccr.net.zone

TTL 3H : 도메인의 수명을 의미 (3시간    /    변경이 가능하다)
@ : 서비스할 영역의 도메인 이름    @ 기호는 origin을 의미한다.
in : internet을 의미
soa : 하나의 존에는 권한의 시작인 soa가 와야한다.    /    도메인당 하나씩만 있을 수 있다. (무조건)
@ : 네임서버의 주소, dns의 주소
dns 관리자의 메일 주소    @ 대신 .을 써야한다.
(    : 그 뒤 부터는 시리얼 번호
refresh : slave 서버가 1차 master 서버의 변경을 확인하는 주기
retry : slave 서버에서 master 서버로 연결이 되지 않을 경우 재시도 주기
expire : master 서버로 연결이 계속 이루어지지 않을 경우 만료 기간
minimum : 캐싱 dns 서버에서 도메인 레코드 유지할 시간 지정

dns는 하루에 몇 번씩 동기화 해줘야한다.
chgrp named cccr.net.zone (그룹 권한을 준다 / 루트 권한이라 접근이 안된다.)
dns에서는 끝에 점을 붙여야한다.

dns round
똑같은 기능을 하는 여러 호스트를 두고 (L4 스위치 목적, 로드 밸런스 : 균형있게 트래픽을 제공) dns에서 번갈아가면서 가르쳐주면 분산이 일어날 수 있다.    =    로드밸런스..?

우리는 호스트를 안 쓰고 도메인만 쓰는데 왜 접속이 될까?    (naver.com을 썼는데 접속이 되는 경우 / 원래 www.naver.com을 써야함)
디폴트 호스트 앞에 특정 호스트를 지정하지 않는다.    /    디폴트 호스트는 회사의 메인 페이지를 걸어놓는다.
웹서버가 아닌 DNS에서 설정이 가능한 영역이다.

mail1    IN    A    10.0.2.30
@         IN    MX 10    10.0.2.30
@는 도메인, 숫자로 우선순위를 줬다.

zone transfer
가용성, 고가용성 모든 것들은 이중화 한다.
dns 서버도 이중화할 필요성이 있다. 2대씩 제공해준다. dns 한대가 고장이 나면 dns를 못하게 되니까
두대를 구축하는게 좋은데, 둘을 따로따로 관리하는건 쉽지않다. 그래서 하나를  master로 두고 다른 하나는 slave로 둔다.
영역 전송이란건 dns를 마스터, 슬레이브로 이중화 구성을 하는것이다.

primary    secondary

마스터는 rw가 가능하지만 슬레이브는 r만 가능하다.
master -> slave로 복제한다. 영역 파일을 복제하기 위함이다. 따로따로 관리할 필요가 없다.
클라이언트는 dns를 줄 때 쌍으로 구성되는걸 dns1, dns2로 구성한다.

dns 포트는 기본은 udp 53번으로 물어본다. 무조건 udp만 사용할까?
dns는 무조건 udp 53번 포트만 써야한다고 정해놓은게 없다.

웹은 신뢰성을 담보로 하기 때문에 tcp를 쓰는 것이고 dns는 정보를 빠르게 받기 위해서 udp를 쓴다.
응답 할 데이터가 많아지면 udp로 전송하면 깨지고 손실될 가능성이 있다.
응답은 udp, tcp 에서 골라서 사용한다. 복제는 tcp, udp 53번을 사용한다.

dns는 tcp, udp 구분 없이 사용하는 프로토콜 중 하나이다.

zon.file.org (참고)

*** host 명령어를 보고 해석 할 수 있어야한다. / 옵션을 사용해서 볼 수 있어야한다. ***
/etc/named.conf
listen .... {any}    -> 모든 인터페이스 서비스
allow-query .. {any} .. -> 누구든지 쿼리를 보낼 수 있다. no로 하면 순환 쿼리만 받는다.

위 두개를 any로 설정 해놓으면 보안을 설정하지 않는 구성이다.

dns가 문제가 있어도 ip를 알고 있으면 접속이 가능하다.

master dns에서는 allow-transfer 항목을 추가해줘야 한다. ( ip만 지정해야한다. / 외부용, 내부용 네트워크가 따로있다?)
slave는 type slave 항목과 masters 항목을 설정해줘야 한다.

allow-notify    =    refresh  ( serial 변경되면 알림, 다르면 요청, 요청 응답 ) 동기화 과정이다.

RNDC (궁금하다면 책 한번 읽어보세요)

UNBOUND (간단하다. 설치하면 끝이다. /etc/unbound/unbound.conf 에서 수정할 수 있다)
전달자 설정이 가능하다 / 순환쿼리가 발생하면 부화가 걸리는데, 그걸 다른 dns로 전달한다.

forwarder : 전달자

bind와 달리 설치만 하면 간단하게 가능하다.
bind 에서도 전달자 설정이 가능하다.    /    명령어 예시 forwarder { dns; dns; }

dns server는 client는 접속 했을 때 똑바로 가면 된다. 작동방식이 중요하다. host command를 사용하고 볼 줄 알아야한다.