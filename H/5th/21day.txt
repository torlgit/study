21DAY

Open ssh

과거에 사용했던 외부에서 네트워크를 통해 원격 접속할 때 사용했던 방식

r command
rsh
rcp
인증을 하지 않는다.    /    인증이 없어서 사용하지 않는다.

telnet 23
원격컴퓨터에 접속하는 프로토콜이자 서비스 패킷을 암호화 하지 않는 단점을 갖고있다. 그래서 사용 안한다.
패킷을 확인하면 ID PW 가 다 보인다.

SSH 22
일반적으로 많이 쓰는 게 Open ssh(유닉스, 리눅스, 맥은 open ssh를 사용한다)
요즘에 나오는 모든 unix system은 open ssh가 기본적 서버로 작동되어있다.
서버라는건 클라이언트가 인증을 하면 접속할 수 있다.

ssh는 scp sftp를 지원한다. secure copy, secure ftp
원격 컴퓨터를 할 때 unix 계열은 ssh를 사용한다.

최근에 나온 윈도우는 ssh 서버 기능을 킬 수 있다.    /    하지만 우린 윈도우 안쓴다.

암호화 방식
RSA 공개키 표준 (전자서명 된다)
DSA 디지털 시그니처 알고리즘 (전자서명 된다)

설정하지 않는 이상 RSA 가 기본 방식으로 사용된다.

ss -tnap
4계층의 정보를 본다
t는 tcp,    a는 all tcp의 모든 상태정보를 보는 명령어
u는 udp, p는 process, n은 프로톸로 넘버, 1은 listen

*= 모든 ipv4를
:: = ipv4를 나타낸다.

서버는 비표준 포트를 사용할 수 있다.
웹서버를 하는데 80번 포트가 아닌 다른 포트를 사용할 수 있다.
비표준 포트를 사용하면 표기가 제대로 안된다.

/etc/ssh
ssh_host_ecdsa_key = ecdsa 방식 공개키    /    ssh_host_ecdsa_key.pub    = ecdsa 방식의 암호키
ssh_host_rsa_key = rsa 방식 공개키            /    ssh_host_rsa_key.pub    = rsa 방식의 암호키

ssh-keygen -lf [key]    *
ssh key를 보여준다.    /    vi, cat 로 보면 키를 볼 수 없게 되어있다.

절대적으로 프라이빗키는 기타사용자한테 권한을 주면 안된다.
공개키는 누구든지 읽을 수 있는 권한이 있어도된다.    /     공개키니까
키는 무조건 쌍으로 존재한다.
ssh 클라이언트가 이 서버에 접근을 할 때 rsa 알고리즘을 사용하면 rsa 대한 키를 요구
상대방의 공개키를 요구하고 서버는 자신의 암호키를 해독

기본 값 ECDSA, fingerprint = 지문
내가 셀프로 확인을 해야한다.

어떻게 검증을 하는가?
클라이언트 측에서 서버가 미리 알려준 공개키를 알고 검증을 해야한다.

중요한건 ssh는 pki * 인증서 구조가 없다. 제 3자 ca가 검증을 해주지 않아서
셀프로 검증을 해야한다. 공개키의 지문을 비교한다.        /        ssh-keygen lf로 암호키를 대조 해보면 된다.

. ssh
known_hosts : 
상대방의 공개키가 저장이 된다.
다음번에 접속을 하면 자동으로 .ssh에서 확인을한다.
접속을 한번이라도 했으면 계속 쌓이게된다.
server의 공인키를 저장해놓은 방식의 파일이다.

만약 서버에서 키를 바꿨으면 어떻게 되는가 ??    /    접속이 안된다. 키를 바꿨으니까.
서버쪽에서 클라이언트한테 키를 바꿨다면 알려줘야한다.    /    클라이언트는 키를 받으면 known_hosts에서 원래 있던 키를 삭제해줘야 한다.
키는 주기적으로 한번씩 바꿔주는게 좋다.    /    /etc/ssh 키 값에 대한 파일을 다 지우고 ssh reload를 하면 다시 만들어진다.

클라이언트가 접속 요청을 한다.
서버는 클라이언트에 공개 키를 전송 (공개키가 화면에 출력)
키와 대조를 해서 맞다면 yes
클라이언트는 비밀키, 시크릿키 (대칭키) 생성을 하고 공개키를 암호화해서 전송을 하고
상대방도 복호화해서 저장을 하고 통신을 하게 된다.

ssh 명령어
계정명@ip
계정을 지정을 안하는 경우 (ssh ip입력) 현재 내가 로그인된 계정으로 접속을 시도한다.
만약에 서버에 user라는 계정이 없다면 로그인이 안된다.    |    내 계정이 안디ㅏ.

ssh localhost = 내가 나한테 접속을 한다.    |    당연히 내 핑거프린트를 보여주고 확인을 한다.
처음 접속을 하면 핑거프린터를 물어본다.

ssh [서버 ip] [명령어]
서버로 명령어를 실행한다.    |    원격으로 명령어를 실행한다.

x11 포워딩 :
gui를  출력하는것 서버에서 실행하고 화면만 나에게 띄운다.    /    서버도 gui가 있어야 가능한 방식이다.
엄밀하게 말하면 나만 있어도된다. (이유는 잘 모르겠다)    /    일반적으로 서버와 클라이언트 둘 다 있어야한다.
서버에서 잘 안쓰는 방식 이라고 한다.

이제까지는 패스워드 기반, 접속시 패스워드를 쓴다.
그런데 클라이드는 키 기반 방식을 사용한다.

ed25519 ECC + DSA 를 한 차 세대 알고리즘, 아직은 잘 안쓴다.
클라이언트가 어떤 알고리즘으로 접속 하는지 모르니까 다 만들어놓는다.

sshd_config (서버 설정)    /    모든 유닉스들은 자신이 클라이언트이자 서버이다.
sshd 바꾸고 서비스를 재시작하면 바꿀 수 있다.
서버는 컴퓨터의 모든 인터페이스를 서비스 다 한다.
네트워크 카드가 10장이 있으면 그 10장을 모두 다 서비스를 해주는데 이렇게 되면 안된다.

ListenAddress : ip 로 접속을 설정할 수 있다.

hostkey를 수정해서 원하는 키 방식으로 통신할 수 있다.

알고리즘이 달라도 접속을 못한다.
ecdsa 방식을 사용하는데 rsa key만 접속 가능하게만 하면 나머지 알고리즘 방식은 접속 할 수 없다.
서버는 보통 클라이언트가 어떤 알고리즘으로 접속할지 모르니 대부분 필요한 형태를 제공 해줘야 한다.

ssh_config 클라이언트 설정

syslogfacility

loglevel

permitrootlogin : 실제 서버는 루트로 로그인을 못하게 되어있다. / 일반사용자 로그인 후 sudo 명령어를 사용

passwordauthentication : password, key 기반 인증을 제공한다 (no를 하면 키 기반 인증)

permitemptypasswords : 패스워드 없는 계정 허용 (절대 하면 안된다)

ssh 키를 바꿔야 하는 경우 키 파일을 지우고 ssh 서비스를 리로드 하면 키파일은 생성이 된다.

인증 중에 제일 약한게 패스워드 인증이다.
중요한건 클라이언트가 키를 가지고 있어야한다. (자신의 키 쌍을 가지고 있어야하고 내 공개키를 서버에 등록 해야한다)
내가 접속하기 위해서 암호키를 보냄녀 등록된 공캐리를 보고 확인을 한다.

known host는 server의 공개키를 저장해놓은 방식의 파일이다.

ssh-keygen
    -t : 키 쌍의 알고리즘을 지정할 수 있다.    /rsa, ecdsa 등
기본으로 디렉토리를 지정해줘야한다. 안 그러면 매번 인증할 때마다 경로 지정해줘야한다.
passpherase : 단락    /    문장을 써도된다.    |    길어도 되는 패스워드를 의미한다.
보통 인터넷을 보면 엔터 2번을 치는데 암호가 없는 방식은 안 좋은 방식이다. (실제로는 암호를 입력해야 한다)

절대로 프라이빗키는 기타사용자에게 권한을 주면 안된다.    (홈디렉토리는 루트가 아니면 아무도 접근 못한다)
복사    /    쓰기 권한도 나밖에 없다.    (default 값이긴하다)

키를 만들면 서버에 등록 해야한다. -> ssh-copy-id user@192.168.56.20 -> authorized_key (rsa 기반) 자동으로 등록하는 명령어 ssh-copy-id
cat authorized_key보면 서버에 대한 공개키가 있다.

패스워드, 키기반 인증 두 가지로 되어있고, 키가 없으면 패스워드 인증을 해야한다.

클라우드에서는 ova를 템플릿, 이미지라고 하는데 컴퓨터를 하나 만들 때 기본적으로 운영체제가 설치된 가상컴퓨터를 띄운다.
거기에 루트나 사용자의 패스워드를 넣으면 안된다.

on-demand 항상 필요할 때 만들어 쓴다.
클라우드 이미지에 root 비밀번호를 주면 안된다. 그래서 key 기반의 인증을 한다. 

NTP 서버

caeium 133 (원자) 약 92억번 진동을 하는데 그게 우리의 1초이다.

NTP 컴퓨터의 로컬 시계, NTP 서버, NTP 클라이언트

NTP의 도움을 받아서 컴퓨터 시간이 잘 맞는다. GPS 도움을 받아서 맞추는 시계도 있다.

www.pool.ntp.org 서버 pool을 모아놓은 주소

UTC : 영국기준으로 세계 협정시간
GMT : 그리니치에서 만든 국제 표준시

ntp는 서버 계층 구조를 나타내고 있다.

startum0은 진동기, gps 위성이고 ntp 서버는 아니다.
startum1 부터 ntp 서버라고 할 수 있다.
startum2 는 클라이언트이며 서버이다.
startum3도 클라이언트이며 서버

이런식으로 계층이 16번까지 있다고 한다.    /    보통 1번은 일반사용자는 막혀있다.

요즘 스마트폰 GPS 수신기는 최소 3개 이상에서 좌표를 받는다.
GPS 2개, 러시아에서 만든 글로나스 등을 이용한다.

정지위성 + 궤도위성
GPS 위도와 경도가 정해져있다.

/etc/chrony.conf
ntp 설정 파일이며 ntp 서버 주소를 지정할 수 있다.

stimedatectl set-time으로 시간을 변경 할 수 있다.    /    timedatectl set ntp 0 or 1 로 on off가 가능하며 서비스를 끄면 동기화를 안한다.
윈도우는 time.window.com가 있다.

방화벽 관리

방화벽 service
iptables
ip6tables
ebtales

방화벽 software
firewalld (레드햇에서 사용)
ufw (우분투에서 사용)

netfilter

운영체제 방화벽은 호스트 방화벽 이라고한다.
커널에 netfilter라는 모듈이 존재한다.
가장 저수준의 도구 iptables command -> 정책을 만들 수 있다.    /    방법이 어렵고 복잡하다.

그래서 추가적인 관리도구를 이용하는데
기본적으로 사용하는 테이블이 있다.    (어렵다)
레드햇은 firewalld를 이용해서 관리하고 우분투는 ufw를 이용해서 관리하는데
리눅스마다 관리도구가 다 다르다.

ml (markup language) 확장자
xlm, html    -    태그를 이용해 문서나 데이터를 명기하는 언어

vi /etc/firewalld/zones/public.xml
여기 정책을 해석해서 iptables -L로 보낸다

내 필터의 정책이 iptables -L에 있다.

block과 drop의 차이
block은 연결이 왜 안되는지 알려주고 drop은 패킷을 폐기하기 때문에 안알려준다.

우리가 앞으로 해야하는 것
패키지 설치
관련 설정파일 설정을 변경해서
원하는 서비스를 하게 해줘야한다.
필요하다면 퍼미션, 디스크 제공
외부에 서비스를 열려면 방화벽을 해줘야 한다.