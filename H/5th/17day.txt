17DAY

스케줄러

스케줄링 :
시스템을 관리하게 되면 특정 시간 또는 특정 주기마다 작업을 실행해야 할 때 명령어, 백업등을 예약을 해서 실행 시킨다.

office 1주일에 한번 update, windows도 주에 한번씩 update message가 온다.

서버 같은 경우 update뿐 아니라 작업파일을 업데이트를 하거나, tar를 이용해서 테이프에 아카이브를 할 때
특히 백업은 정말 많은 리소스를 소모 해야 하기 때문에 업무 시간에는 속도 저하가 올 수 있어서
새벽 또는 주말 새벽에 예약을 해서 작업을 하는데,

직접적으로 명령어를 쳐야할 경우 작업자가 스케줄러를 동록해 놓으면 특정 시간에 특정 어플리케이션을 작동 시킬 수 있다.

단일성 작업 :
한번 실행하고 다시 실행하지 않는 것
다시 실행 하려면 스케줄러를 또 등록해야한다.    /    일반적으로 많이 쓰이지 않는다. 사용법도 간단하다.

커맨드 - at

주기적 작업
crond 시스템이 부팅을 할 때 crond을 작동 시킨다.    /    주기적으로 작업도 되고 1회성 작업도 가능하다.
특정 시간, 날짜에 예약을 해서 실행 할 수 있다.
주기성 작업도 가능하지만, 단일성 작업도 가능해서 at를 잘 안쓴다.

crontab 명령어
/etc 디렉토리 밑에 tab이란 파일이 몇 가지 있는데, 테이블을 나타내는 파일들이다.
액셀의 테이블 시트를 예로 들 수 있는데, 액셀과 같은 테이블은 아니지만 테이블을 텍스트로 구현해놨다. 명령어를 실행해보면 감이 올거다.
(정보목록을 가지고 있다)

which crontab

clontab -l
no crontab for user - crontab이 없는 것을 나타낸다.

crontab -e (edit)
테이블 형식으로 (분, 시, 일, 월, 요일, 명령어) 순서로 텍스트 저장을한다.
여러가지 형식의 작업을 하고 싶으면 한 줄에 한 테이블씩 작성을 하면된다.

분은 숫자로 입력 0~59까지
시는 24시간 형태로 0~23까지
일은 1~31까지
월은 1~12 또는 문자로 세 자리 이상
요일은 0~7, 0과 7일은 일요일    /    세 자리 이상 문자로도 사용이 가능하다.
명령어 command.

메타문자 (특수문자가 의미를 갖고 있는 형태)
grep, shell 처럼

* : 매 요일, 매 분, 매일을 의미한다.
- : 숫자인 경우 범위를 나타낼 수 있다.    /    요일에 1-6 (월~토)를 나타냄
, : 여러가지 항목을 지정 할 수 있다.    /    분인 경우 10,20,30,40,50 (10분마다 의미)
각 필드당 공백으로 구별한다.
/ : 조건에 대한 주기를 지정한다.    /     */10 = 10,20,30,40,50 10분마다를 의미한다.

0 0 30 1 1 로 지정 했을 때, 1월 30일이 월요일이라는 조건이 충족되면 실행이 된다.
-e 파일 수정, 자신 계정 ID가 들어간다.

crontab은 특정시간에 특정 명령어를 실행하기 위해서 사용한다.
파일을 사용하여 crontab 등록 = 아규먼트, 파일을 등록하면 자동으로 실행    /    잘 쓰이진 않는다.

crontab -r 몽땅 다 지워진다.    /    특정 작업만 지우고 싶으면 -e로 해당되는 내용만 지워야한다.

system cron (관리자가 사용하는 것 | 다른 사용자 권한)
그전 형식은 user가 사용
일반 cron은 내 소유권이다.

cron의 문제 :
특정 시각을 지정해놨는데 시스템이 꺼져있다면?     ->    실행을 안한다.
이걸 위해서 anacron이라고 개선이 되어서 나왔다.    |    주기능은 아니고 보조기능이다.

etc cron.d 파일 또는 /etc/crontab 디렉토리에 파일을 생성하여 작업을 예약한다.
cron.d *    (daily, hourly, monthly, weekly) 등

어플리케이션 설치 시 자동 등록이 될 수 있다.
anacron은 형식이 틀리다. 실행 할 수 있는 모든 것 shell, script (실행권한이 있어야한다.    /    쉘 스크립트 형태)
터미널을 이용하지 않는다.

쉘을 이용한다랑 터미널을 이용하는건 다르다.
기본적으로 프로세스들은 터미널 없이 쉘만 갖고 실행이 가능하다.
터미널은 우리한테 필요하지만, 시스템에는 필요없다.

period in days - 작성 발생 일 수 (1일에 한번, 7일에 한번, 달에 한번)
delay in minute - 특정 발생 시간
job-identifier - 로그에 표시된 ID ( 식별자)
command - etc/cron.d 실행

cron - 일반 : /var/spool/cron
          시스템 : etc/corntab
                             .cron.d
                             .cron.hourly

anacron    /etc/anacrontab
                      /cron.daily
                      /cron.month
                      /cron.weekly

디스크 관리  

motherborad = 메인보드, logic board 등
IO를 어떻게 처리할지 결정한다. (input, output)    /    데이터송수신, read&white
데이터의 입출력, 데이터의 구조를 알고 있어야한다.
나중에 클라우드 (가상) 으로 하지만, 피지컬(물리적)  으로 하는 것과 구조가 바뀌지 않는다.

메인보드 구성

northbridge (포트, interface)

southbridge

옛날 컴퓨터는 이렇게 두 가지로 나뉘었는데, southbridge가 하는 역할을 cpu가 해서
요즘엔 브리지 또는 메인보드의 칩셋이라고 한다.
모든 입출력 장치를 통제하는게 브리지이다.

그래픽카드는 부동소수점 연산을 잘하게 만들어졌고, cpu는 정수 연산에 최적화 되어있다.
3d게임 같은 경우는 부동소수점 연산을 많이 해야한다.
똑같은 기능을 하는 소프트웨어보다 하드웨어가 빠르지만, 모든 기능을 하드웨어로 만들 수 없다.

form factors : 메인보드의 생긴 모양, 크기, 구조    /    서버는 standard, 가정용 micro atx
dram : 보통 우리가 사용하는 램    /    ddr4가 현재표준

ISA (거의 볼 수 없다. 20~30년됨) -> PCI/AGP (그래픽카드 전용, 지금은 X) -> PCIe
10진 단위를 SI라고 한다. (접두어 prefix)

디스크를 PCIe로 연결하는 디스크를 만든다.

디스크를 연결하는 IO 방식
IDE(parallel ATA) 병렬 ATA, 표준 E-IDE (IDE 마지막으로 쓰던 .....)    /    SATA : 직렬 ATA
통신하는 방식은 직렬, 병렬이 있다. UTP 직렬    /    네트워크 통신이든 IO든 직렬로 통신한다.

병렬은 8개의 선이 있으면 1초 8bit를 한번에 전송    /    직렬 방식은 8bit를 보내는데 8초가 걸린다.
   : 한꺼번에 많은 정보를 전송하기 때문에 이론상으로는 빠른게 맞을 수 있다.    |    병렬은 멀리 전송하는게 어렵다.
    우리가 전송하는 속도가 옛날에 비해 어마어마하게 많이난다.
    길이가 조금만 틀어져도 제대로된 송수신이 안되서 병렬을 쓸 수 없다. 그래서 대부분 통신은 직렬통신이다.

DMA : 167MB/s 최대의 속도
Esata : 디스크를 컴퓨터 외부에 꼽는 방식    /    usb보다 빨랐지만 요즘엔 안쓴다.

IEEE 1394 : USB가 너무 느려서 사용 했었다.    /    USB를 통합해서 현재는 사용하지 않는다.
USB가 포트도 간결하고 쓰기도 쉽다.    3부터 3.1, 3.2로 구별한다.
Thunderbolt 3
Infinband : 서버에 존재하다.    /    특이한건 시스템 IO처럼도 작동하고, 네트워크 기능도 있다.

서버같은 경우는 SCSI (스커지) : 병렬 통신, 옛날 통신방식 -> sas : 직렬 연결된 스커지 서버에서 사용
SATA - SAS는 IO가 호환이된다.

SCSI, SAS, SATA => HOT Plugin    =    USB, flash memory
온라인 = 현재 실행되고 있는 것 = hot    /    오프라인 = 시스템이 꺼져 있는거 = cold
PnP (plug and play) = 연결하면 작동한다.

확장 플러그인(확장포트) = hot plugin 적용이 안되서 재부팅을 해야한다.
아주 고가의 서버는 hot plugin 적용되지만, 아주 드물다.
현재 사용하는 장치를 빼면 안된다. = cold / usb는 필요에의해 탈착 가능 = hot

SCSI command 내부적으로 파일을 저장하거나 읽을 때 (프로토콜이라고 생각해도된다) SCSI  명령어를 쓴다.
SATA랑 SAS의 포트의 모양이 똑같다. SATA의 Disk를 SAS에 연결 할 수 있다.
SAS의 디스크는 물리적으로 똑같기 때문에 연결이 안된다. (동작이 안된다 / SAS의 기능이 많기 때문에)

HDD = 하드 디스크 드라이브
3.5형 = 3.5 인치    /    디스크 컨트롤러 (DISK IO) : SATA3    /    7200RPM 분당 속도    /    메모리 BUFFER MEMORY
노트북은 2.5인치를 사용한다. 5200RPM으로 느리다.
10K, 15K 으로 부르고 서버에서 사용한다.    /    15000RPM

SSD = 기본적으로 SATA    /    2.5인치, SAS용은 없다.
IOPS = input, output 처리량
SSD는 용량이 크면 클수록 용량이 더 빠르다.

M2 SATA = 노트북용으로 만든 SSD    /    모양은 M2인데 SATA를 쓰는 방식
NVME = 서버용으로 사용하는 SSD = SATA 방식이 아닌 PCI 방식을 사용한다.

ALL flash storage    //    PCI, M.2

디스크의 물리적인 구조

플래터(platter) : 실제 데이터가 저장되는 위치, 디스크에는 한 개 이상의 플래터가 존재하고, 양면기록이 가능하다.

스핀들(spindle) : 플래터를 회전시키는 역할을 담당한다.
    rpm(round per minut) 스핀들 모터의 회전속도를 의미한다.

헤드(haed) : 플래터에 데이터를 기록하는 기능

액추에이터(actuator) : 디스크 플래터를 원하는 위치에 있는 데이터를 읽어오기 위한 암을 이동시키는 역할

액추에이터암(actuator arm) : 액추에이터에 의하여 움직이고, 암마다 헤드가 붙어있다.    /    좌우로 움직인다.

커넥터(connector) : 디스크의 연결 인터페이스 종류에 맞는 케이블을 연결    /    IDE, SATA, SCSI, SA-SCSCI 등을 사용

점퍼 블록(jumper block) : IDE 인터페이스를 사용하는 하드 디스크의 경우 master/slave 결정하기 위한 점퍼

전원 커넥터(power connector) : 디스크 구동에 필요한 전원케이블을 연결한다.

하드디스크는 기계적, 물리적으로 읽어야한다. 실제로 데이터를 읽거나 쓸 때 더 오래걸린다.

seek time : 하드 디스크를 읽고 쓰는 역할을 하는 헤드가 원하는 데이터가 있는데 위치를 찾는데 걸리는 시간

rotational latency : 헤드가 트랙 내에서 원하는 블록까지 가는 시간

transfer : 디스크 전송속도 플랙터와 주고 받는 속도 트랙 1인치에 얼마나 많은 비트를 쓸 수 있는지 정의

디스크 플래터의 논리적인 구성요소
섹터 (sector) : 플래터의 가장 작은 단위, 1개 섹터 크기는 512byte 이다.
가장 기본단위이며, 가장 작은 입출력단위이다.
1bit든 10bit든 하나의 섹터를 전송해야한다.

트랙 (track) : 섹터가 모여 하나의 원을 구성하는데, 트랙은 많은 수의 섹터를 가지고 있으며, 플래터 내에 여러 개의 트랙이 존재한다.
섹터가 한 바퀴 돌면 트랙이라고 한다.

실린더 (cylinder) : 여러 트랙을 모아놓은 것

디스크 (disk)    >    파티션 (parttition)    >    실린더 (cylinder)    >    트랙 (track)    >    섹터(sector)

커널은 파일시스템을 논리적으로 만들어서 관리한다. 운영체제가 IO하는 최소 단위
UNIX    =    Block    /    WINDOWS = cluster 파일의 최소 입출력단위
물리적인 섹터의 배수가 되어야한다.

파일 사이즈
한번에 처리할 사이즈
Block    /    Cluster    4kb  = 512byte  1 block = 8개의 섹터

디스크 파티션 :
논리적으로 구역을 나눈다.    /    정보를 저장하는 방식
MBR,방식과 GPT 방식으로 나뉜다.    ->    inode table = 메타데이터 = 파티션도 포함되어있다.

MBR 저장방식
MS가 dos부터 사용한 방식    ->    현재 리눅스에서도 사용 가능하다.

MBR(master boot record) 파티션
boot code 0 ~ 440        /    bootloader, bootstrap
Signature 440 ~ 446
partition 446 ~ 460
partition table 460 ~ 476
partition table 476 ~ 492
partition table 492 ~ 508
Signature 508 ~ 512

MBR은 파티션을 최대 4개까지 밖에 나누지 못한다.
4개 이상의 파티션이 필요할 경우 확장 파티션 기능을 사용하여 4개 이상의 파티션을 사용할 수 있다.

섹터의 주소를 4 byte로 저장하기 때문에 최대 크기 제한이 발생한다.
한 개의 섹터는 일반적으로 512byte이고
최대 섹터 크기는 2의 32승 약 43억개 정도이다.이걸 용량으로 환산할 경우 2TB가 나오는데,
만약 4TB가 있으면 2TB까지만 인식이 되고 나머지는 인식이 안된다.

GPT(guid partition table) 파티션
파티션 테이블 개수가 128개로 늘어났고, 각 파티션 테이블 당 128 byte씩 사용할 수 있다.
섹션 주소를 64bit로 저장하여 최대 8 ZB 까지 디스크를 사용할 수 있다.
GPT는 주파티션, 확장파티션의 개념이 없다.

 하나의 디스크 크기    /    지금은 부족 하지 않지만 IT 발전속도에 의해 8 ZB라는 용량이 부족해질 수 있다.

MBR 방식 디스크 구조
MBR    |    Partition 1    |    Partition 2    |    Partition 3    |    partition 4    |

GPT 방식 디스크 구조
Protective MBR    |    Primary GPT    |    Partition 1    ......    Partition n    |    Secondary GPT

BIOS (Basic input    /    output system) :
컴퓨터를 키면 제일 먼저 실행 (MBR 형식만 인식이 가능)

EFI/UEFI (Extensible Firmware Interface /Unified EFI) :
바이오스, MBR, GPT 다 가능하다.

BIOS, EFI/UEFI는 POST 과정 중 실행한다.

MBR
GPT
ARM (애플 방식) / MBR, GPT 지원
BSD (리눅스 방식) / MBR, GPT 지원

리눅스 시스템 스토리지 장치명
인터페이스별 장치명    +    장치 번호    +    [파티션번호(숫자)] 
    장치번호는 숫자, 문자를 의미한다.
    windows는 파티션마다 할당    /    unix는 하나의 장치 = 하나의 번호    |    1부터 시작한다.

E-IDE 인터페이스
'hd' 장치명을 사용한다.    /    장치명은 hd부터 순차적으로 알파뱃이 붙고, 파티션 번호는 1부터 순차적으로 부여된다.
ex)    hda            /dev/hda        |        hda1            /dev/hda1 등

현재 최신 리눅스 시스템은 과거 hd 명명 방식을 사용 하지 않고 sd 명명 방식으로 통일되었다.    -> EIDE는 현재 안쓴다.

SATA    /    SCSI    /    SA-SCSI
'sd' 장치명을 사용한다.    /    어떤 방식을 사용하든 전부 통일 시켰다.
ex)    sda            /dev/sda

CD-ROM (ODD방식)
unix 마다 sd or sr로 나뉘어지는데 서버에선 ODD를 안 쓴다.
ex)    sr            /dev/sr0

핫 플러깅 :
스커지만 해당 된다. 장치를 인식 시키고 장치 파일을 생성하는 방식    |    현재는 사용하지 않는다.
스캔을 하면 새로 장치가 보이면서 스캔이 실행된다.
echo '- - -' 명령어를 사용해서 스캔한다.

잘 사용하지 않지만 스커지를 할 경우 책 97~98를 참고하자.

fdisk MBR 방식
gdisk GPT 방식
pated 안쓴다    /    gparted 안쓴다

디스크 인식    ->    파티션    ->    p. s 생성    ->    mount    /    /dev/[파티션] * 실습 후 수정
윈도우는 mount 전 까지 unix와 동일하다.    /    파티션이 여러 개면 여러 개의 ps, mount가 존재한다.

fdisk(MBR), gdisk(GPT) :
파티션을 나누는 명령어

p107 복사 설명 쓰기

파티션을 포맷을 하려고 할 때 사용 하는 방식
dd if =/dev/zero of=/dev/sdc bs=512 count=500
파티션 c를 zero로 덮는다.

시큐어딜리트 :
보안삭제 위 과정을 15번 하면 데이터가 없어진다.    /    디스크 사이즈에 따라 시간이 바뀐다.

파티션 설정 시 주의사항
파티션과 파티션의 데이터가 겹치면 안된다.
파티션과 파티션 사이에 사용되지 않는 데이터를 남기면서 만들면 파티션이 꼬인다.
파티션과 파티션을 겹치면 안된다.

확장 파티션
확장 파티션은 MBR 방식 파티션에서 4개 이상의 파티션을 사용 할 수 있는 방법을 말한다.
세 개의 주 파티션이 생성되어진 디스크를 대상으로 확장 파티션을 생성 할 수 있다.

Primary : 주    /    Extended : 확장    =    확장 파티션 안에서 논리적으로 파티션을 나눈다.

주 파티션 3, 확장 파티션 1개 까지 만들 수 있고, 주 파티션에만 운영체제 설치가 가능하다.

primary 파티션을 4개 만들 수 있는 이유 :
운영체제가 여러 개 있을 수 있어서, 옛날에는 한 컴퓨터에 운영체제를 여러 개 설치해서 사용하기도 했다. 
현재는 컴퓨터에 운영체제를 여러 개 설치하지 않는다.    ->     ?       ->    가상화를 하면 되니까 굳이 여러 개 설치할 이유가 없다.
여러 개를 설치하다보면 충돌이 나거나 막히는 부분도 생긴다.

리눅스의 디스크 파일시스템

디스크 기반 파일 시스템 :
디스크 기반 파일 시스템은 하드디스크, CD-ROM, DVD 등을 기반으로 하는 파일시스템이다.

MINTX : 유닉스의 한 갈래인 미닉스에서 사용하던 파일시스템 플로피 디스크 등 작은 크기의 저장소 장치로 사용되는 파일시스템
    -    안쓴다.

EXT : 유닉스의 한 갈래인 미닉스를 토대로 만든 확장 파일시스템이다.
    - 리눅스에서 일반적으로 사용하는 파일시스템    /    50TB까지 가능하다.

XFS : IRIX에서 사용되던 파일시스템인데 리눅스로 이식되었다. 레드햇 기반이 기본 파일시스템으로 사용한다.
    - : 퍼포먼스가 EXT에 비해 밀린다.    /    500TB까지 가능하다.

FAT : MS에서 만든 초기 윈도우용으로 개발된 파일 시스템    /    현재는 USB등 이동식 저장장치에서 주로 사용 (FAT를 말하면 보통 FAT32이다)
    - : FAT은 MS에서 공개했다.    NTFS는 MS에서 공개를 안했고 UNIX에서 쓰기가 안된다.    /    EXFAT - 안드로이드에서 사용한다.

ISO9660 : CD-ROM 파일세스템, 운영체제 및 플랫폼에 무관하게 사용가능한 표준 방식

 UDFS : DVD 표준 파일 시스템    /    안 쓴다.

분산 파일시스템 :
분산 파일시스템은 네트워크를 통해 파일시스템의 자원을 접근할 수 있도록 지원하는 파일 시스템

NTFS : Sun Microsystems에서 개발된 네트워크 기반 분산 시스템 유닉스/리눅스에서도 사용할 수 있는 분산파일시스템 방식이다.
 - : windows 기반에서 사용한다.    /    공식적으로 공개한적 없으며 유닉스,리눅스에서도 쓸 수 있지만 공식적으로 지원하진 않는다.

SMB : NetBIOS 기반의 파일 장치 공유 프로토콜이다. 윈도우 운영체제, 유닉스/리눅스 운영체제간 디렉토리 및 파일 공유 기능을 제공한다.

Pseudo 파일 시스템
swapfs : 물리 메모리를 보조하기 위한 디스크 내의 스왑영역에서 사용하는 파일 시스템    /    내일 할 내용

tmpfs : 임시 파일 시스템, 메모리 기반이므로 데이터 보관을 보장하지 않는다.

fdfs : 파일 설명자 파일시스템 /dev/fd 디렉토리를 사용할 수 있는 명시적인 이름을 제공하고 있다.
    - : 표준입력, 표준출력, 표준에러

procfs : 현재 동작중인 프로세스의 목록을 관리하는 파일시스템. ps 명령어를 사용하여 확인할 수 있다.
    - : 메모리 접근    /    커널관리

devfs : 디바이스 파일 시스템은 시스템에서 사용하는 모든 디바이스의 이름 공간을 관리하 위해 사용.
    - : 장치파일관리

메모리 영역에서 커널이 관리하는 메모리 이며, 전원이 없으면 소멸한다 tmp, dev 등.

EXT4 파일 시스템 :
EXT3에서 저널링 기능이 추가 되었다. 기록(로그)을 생성하고 변경한 데이터의 내용을 기록, 
저널링 기능을 사용하면 데이터 기록도중 오류가 발생했을 때 복구할 수 있다.
안전성의 문제로 50TB만 사용한다. / 50TB가 많아보이지만 기업에선 많은 데이터가 아니다.

일기 = journal    /    파일이 깨지면 방법이 없는데 이전 상태로 돌아갈 수 있다.

파일시스템에 대한 주요 정보가 슈퍼 블록(super block)에 저장된다.    /    meta date. inode에 저장된다. file system 에디션 정보
inode를 사용하여 파일의 메타정보와 데이터를 분리하여 저장한다.
옛날에는 전원이 나가거나 강제 종료시 파일, 디스크가 깨졌는데, 현재는 깨지는 경우가 드물다.

버클리 파일시스템     ->    유닉스 최초적용
: 슈퍼블록, inode로 파일 구별

inode구조
파일 유형, 권한 정보, UID, GID, 파일 크기, 시간 정보, 하드링크 개수, 파일크기 등등
0~11의 직접 포인터, 12 단일 간접 포인터, 13 이중 간접 포인터, 14 삼중 간접 포인터

블록주소 저장    /    이중 간접 포인터는 단일보다 한번 더 거친다. 삼중은 이중보다 한번 더 거친다.
파일은 블록 기준으로 IO 한다.

4K 기본    /    옛날에는 48 이상의 파일을 구분 할 수 없었다.

XFS 파일시스템 :
레드햇 계열에서 사용하는 파일 시스템 / ETX4와 가장 큰 차이점은 용량 (ETX4 = 50 TB)
안전성의 문제로 500TB만 사용한다.

ZFS - 유닉스

LVM을 가지고 있다. 논리 볼륨 관리자.

BTRFS : 오라클에서 만든 파일 시스템    /    도입하려 했으나 8 버전에서 도입  안됨. 정치적 문제가 아닐까.. IT회사는 오라클 싫어해.. 오라클 DB

Mount :
파일시스템을 생성한 후에는 파일에 접근할 수 있는 경로를 생성해야 한다. 이 과정을 mount 라고 한다.
파일시스템의 고유번호(ID)로 마운트 하는게 좋다. 파일시스템의 고유번호는 변하지 않기 때문이다.
파일시스템을 변경하면 데이터가 날아간다.

mount - 모든 시스템을 볼  수 있다.    /    umount : 마운트 해제
/dev/[파티션테이블], [마운트포인트]    ex mount /dev/sdb1 /mnt/new    /    마운트 포인트 연결

/etc/mtab -> mount table = mount
mount 명령어를치면 mount table에서 갖고 와서 보여준다. 마운트 테이블은 커널이 관리하기 때문에 수동으로 수정하면 안된다.    | 절대로 xxx

df : 마운트 확인 (시스템에 마운트된 디스크 사용량을 확인하는 명령어)
    -h : 사람이 보기 쉽게 데이터를 표현한다.

mount 명령어 -o defult 옵션
rw    : 읽기/ 쓰기 가능 상태로 마운트
suid : 파일시스템 내 setuid 설정을 사용
dev  : 파일시스템 블록/캐릭터 장치 해석
exec : 파일시스템 내 바이너리 파일을 실행
auto : -a : mount 명령의 -a 옵션으로 마운트 한다.
nouser : 관리자가 아닌 일반사용자에 의한 마운트를 금지
async : 파일시스템의 입출력을 비동기로 처리

mount -o 기타 옵션
ro    : 파일시스템을 읽기 전용 모드로 마운트
atime : 파일 inode 접근 시간 (access time)의 갱신을 허용 (<=> noatime)    / noatime (defult값) -> 성능향상이 있다.
remount : 파일시스템을 다시 마운트    /    마운트 옵션 수정 시 사용    새로운 마운트 할 때
sync : 파일시스템 입출력을 동기화 (synchronous) / 기본은 비동기화 분산 파일시스템과 관련있다.

blkid에 파일시스템, 마운트 없으면 마운트가 안된거다.
partprobe    /dev/[파일시스템]

마운트는 보통 시스템을 재부팅하면 사라진다. (서버는 재부팅을 할 수 없다)
한 줄에 하나씩 파일 시스템

UUID=12345678-1234-1234-1234-123456789ABC    /test    ext4    defaluts    0    0
장치 ID    /    디렉토리    /    형식    /    옵션    /    Dump 유무    /    파일시스템 체크
Dump 0은 안되고 1은 된다.    /    백업 유무    |    파일시스템체크 fsck (원래는 해야한다  0이 아닌 다른 값을 넣으면된다)

umount -a (umont all)
mount -a (mount all)

부팅 시 마운트가 안되면 부팅이 안된다.
마운트 할 때 busy가 나오면 쓰고 있다는 의미이다.

umount [옵션] {파티션 | 마운트포인트 | UUID}    /    {} 선택 옵션


DAS : 서버, 네트워크를 거치지 않고 직접 연결된 저장장치

NAS : 스토리지 서버
    - NFS
    - SMB

SAN : DAS와 비슷한 역할
    - ISCSI
    - FC-SAN

스토리지용 네트워크 (전용 네트워크 사용)
구축비용이 엄청나게 비싸다.