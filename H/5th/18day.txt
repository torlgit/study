18DAY

어제 배운 내용

병렬                        |                        직렬
IDE(PAT)                 ->                      SATA
SCSI                       ->                       SAS

SCSI (스커지 커맨드를 사용)

먼 곳을 통신할 때 병렬방식은 좋지 않아서 IT는 대부분 직렬방식으로 통신한다.

/dev/hd (IDE 방식)            - 안 쓴다.
        /sd
        /sr

disk 인식 -> 파티션 -> F.S 생성 -> mount

파티션
MBR 방식 :
2TB까지 사용 가능하며, 32비트 파티션 4개 까지 만들 수 있다.
주파티션, 확장파티션 (논리파티션)이 있다.
GPT 방식 :
64비트로 이루어져있으며 128개의 파티션이 있다.    /    주, 확장의 구분이 없고 모두가 파티션이다.

파일시스템
EXT : 50 TB
XFS : 500TB
용량 외에도 차이점이 여러 다른 차이점이 있지만 일단은 용량 차이가 있다는 것만 알아두자.

Mount
/etc/fstab
/etc/mtab
으로 관리하며, /etc/mtab은 커널이 관리하므로 직접 수정을 하면 안된다.

스왑 메모리
virtual memory  = 가상메모리    =    physical memory (RAM) + swap space
자기가 사용 할 수 있는 총 메모리는 virtual memory로 인식을 한다.    (예 : ram이 2기가고 swap 메모리가 2기가면 4기가로 인식)
swap은 있을 수도 있고 없을 수도 있다. 없다면 physical memory (ram)의 크기와 동일하다.

메모리는 디스크에 비해 용량대비 고가이다. 
메모리가 용량이 커야 동시에 여러 프로그램들을 돌릴 수 있는데 메인보드 칩셋에 따라 메모리량이 정해져있다.

결론적으로 메모리는 계속해서 늘릴 수 없을 뿐더러 용량대비 너무 고가이다.
디스크의 일부분을 메모리처럼 사용 하는 방식을 swap space라고 한다.

아무것도 안하고 있는 것만 swap 으로 간다.    /    동작을 하게 되면 다시 메모리로 사용한다.
swap을 하는 이유는 메모리를 늘리려고 한다.

swap out : 안 쓰고 있는 프로그램으로 swap이 되는 현상
swap in : 안 쓰고 있는 프로그램을 다시 사용할 때 memory로 돌아가는 현상
메모리 기준으로 in, out 해야한다.

Hibernation :
    절전
    최대절전 - Hibernation

절전, 최대절전 : 기본적으로 컴퓨터를 일시정지 시키는 현상
절전 : 시스템이 꺼져 있는 거 처럼 보이지만 켜져 있는 상태로 전원이 계속 돌아가고 있다.
최대절전 : 메모리에서도 전원을 차단해서 절전을 더 많이 할 수 있게 한다.    /    memory에 있는 걸 swap 에 저장 시킨다.

최대절전을 사용하려면 swap 공간이 physical memory 용량보다 더 커야 사용이 가능하다.
서버에는 해당 사항이 없다.    /    서버는 일반적으로 많은 메모리를 제공하는게 목적이다.
메모리가 충분하게 있다면 swap memory는 굳이 필요하지 않는다.

swap은 성능을 높이고 많은 메모리를 사용하긴 하는데, swap memory가 HDD - 5400 RPM 같은 느린 장비를 사용하면 병목현상 발생 및 전송 속도 저하가 올 수 있다.

Page : swap의 단위

getconf PAGESIZE :
swap은 page 단위로 in, out을 한다.    =    paging (페이징)

모든 OS는 메모리와 swap 을 paging  단위로 in, out 한다
ms 에서 swap 이란 단어를 사용하지 않는다.

swap file = swap disk    /    swap partiton (많이 사용한다    /    요즘 선호하는 방식)
swap file은 file 제공으로 partition보다 느리다.
partition을 나눌 수 없으면 file을 만드는 방법 밖에 없다.
ms는 파일로만 관리한다.    /    c드라이브 밑에 pagefile.sys (숨김파일) = pagefile // virtual memory

p.s을 생성을 하고 허용을 해줘야한다. (파티션 - 마운트 과정과 비슷하다)

기본적으로 처음에 운영체제를 설치 할 때 memory에 따라 swap을 정한다.

free command
mem (physical)
swap memory

메모리가 꽉 차야지 swap을  하는건 아니다. 메모리가 꽉 차지 않아도 swap을 할 수 있다.

mkswap    /dev/[장치]
파티셔닝 한 후 파티션에 스왑 영역을 생성 해야 되는데 이 때 사용하는 명령어는 mkswap

swapon [옵션] [파티션 | 파일이름]
    - p : 우선순위에 해당되는 스왑장치를 더 많이 쓴다.    (연결한 장치 순서대로)    /    ssd 같은 고속 장치를 사용하면 그 장비를 우선순위 주면된다.

swapoff -  조건에 해당되는 장치가 사용하고 있으면 안된다.

fstab에 기록 했다면 현재 상황에 맞게 수정해줘야한다. (기록한 파일만 삭제해야한다)

swap을 사용하려면 파티션이 빠르다. 파티션이 없는 상태에서만 파일을 고려해 볼 수 있다.
더 많은 프로세스, 최대 절전을 고려 했을 때 swap이 존재해야한다.

일반적인 형태에서 swap을 하는 사이즈

vi /etc/fstab을 추가, 삭제를 반영해서 지우기
swapoff -a, umount -a    /    sda는 건들면 시스템 날아간다.

dd if=dev/zero of =/swapdir/swapfile bs=512 count=1048576
dd 명령어를 사용 할 때 [if] 는 복사할 파일을  [of]에는 생성될 파일을 [bs]에는 복사할 때 사용할 블록의 크기를 바이트 단위로, count에는 복사할 횟수
/dev/zero 파일을 지정해서 복사할 경우, [of]에 지정된 파일의 데이터가 모두 0으로 채워지는데 이걸 512byte 씩 1048576번 한다.

LVM (Logical Volume Manager) 
= 논리적인 볼륨을 관리한다고 해서 볼륨관리자 라고 한다.

disk를 단일 파티션 3개로 묶어서 하나의 volume을 만들 수 있고 f.s를 생성해서 사용할 수 있다.
앞에서 했던 파티션은 사이즈 조정이 안된다.    /    사이즈 조정이 되는데 삭제했다가 다시 만들어야된다. (데이터가 다 날라간다)

vloume이란걸 만들게 되면 파티션의 사이즈 조정이 가능하다.    /    볼륨에선 제일 중요한건 Raid를 지원한다는점이다.
기업에서는 볼륨, 레이드가 중요하다.

disk    ->    partition (필요에 따라서 나눈다)    ->    lvm    ->    f.s   ->    mount

논리 볼륨의 구성
disk를 물리 볼륨 (PV) 디스크, 파티션 하나 하나를 물리 볼륨으로 구성해야 한다.
5개의 디스크가 있다면 5개의 PV로 만든다.
나눈 PV를 합쳐 VG(볼륨 그룹)을 만든다.
VG를 필요에 따라 논리 볼륨(LV)로 나눠서 사용한다.

LV에 P.S를 만들고 Mount를 해주면 된다.

Device Mopper(dm) 장치를 연결 시켜준다.    /    /dev/dm
dm은 장치 연결을 자동으로 만들어준다.    /    늘릴 수 있지만 줄이는 건 불가능하고 줄일 이유도 없다.

/dev/[vg]/[lv]

ms windows는 volume 매니저가 있다. 조절이 가능하다.
베리타스 볼륨매니저 라는 소프트웨어를 사용한다.    /    옛날부터 있었다.
VM(볼륨매니저) 가 기본으로 작동한다.

물리 볼륨 :
논리 볼륨으로 구성하기 위한 가장 기본적인 단계, 디스크 전체 또는 일부를 파티션으로 지정하고 물리 볼륨을 생성한다.

볼륨 그룹 :
1개 이상의 물리 볼륨의 집합으로 구성되어 있다. PE의 크기를 정한다.     /    defult 값은 4mb

논리 볼륨 :
파일시스템에서 데이터를 저장할 수 있는 볼륨을 생성하는 단계    /    논리 볼륨 생성 단계

lvmdiskcan :
파티션 정보를 확인할 수 있는 명령어

pvcreate [장치] :
파티션 장치를 지정하여 물리 볼륨으로 변환하는 명령어

pvremove [장치] :
물리 볼륨을 삭제하는 명령어

vgcreate [옵션] [그룹이름] [장치] :
    - s : PE의 크기 단위로 할당 및 조정 하는 옵션    /    기본 값은 4MB

볼륨 그룹을 만드는 명령어

vgremove [그룹이름] :
볼륨 그룹을 삭제하는 명령어

lvcreate [옵션] [볼륨이름] [그룹이름]
    - l : 생성할 논리 볼륨의 크기를 PE 개수로 지정 옵션
    - L : 생성할 논리 볼륨의 크기를 사이즈로 지정 옵션
    - n : 생성할 볼륨 이름을 지정하는 옵션

논리 볼륨을 생성하는 명령어

lvremove [볼륨경로] :
논리 볼륨을 삭제하는 명령어

dm2    - /dev/dm-2
             /dev/mapper/[볼륨]

LVM을 사용하지 않으면 일반파티션이 되는데, 일반파티션은 확장이 안된다. LVM은 파티션 확장이 가능하다.

논리볼륨 지울 때는 역순으로 지워야한다.

삭제 할 때 장치명이 하나라도 남아있으면 안지워진다.
물리 볼륨으로 변환 할 때 파티션을 나누지 않을 경우는 굳이 파티션을 나눌 필요가 없다.    /    명령어 입력하면 파티션을 안나눠도 하나의 물리 볼륨 생성이 가능하다.

선형 논리 볼륨 :
일반적인 방법으로 생성되어 있는 논리 볼륨의 형태를 선형 논리 볼륨이라고 한다.
전체 물리 볼륨의 PE를 나열하고, 생성할 논리볼륨에 순서대로 PE를 할당하는 방식이다.

LVM을 이용해서 RAID를 만들 수 있다.
RAID (중복대열)    /    합친다.

옛날에는 큰 디스크가 필요하면 디스크가 비싸서 싼 디스크를 여러 개를 합쳐서 큰 디스크를 만들었다.
개별독립적인 디스크를 여러 개 묶어서 하나의 볼륨으로 묶는 방식

스프라이프 볼륨(striped volume) :
스토리지 사이즈와 성능을 중시하는 논리 볼륨 생성 방식
LVM과 같이해서 데이터를 갖고 해야한다. 양쪽의 데이터 사이즈가 항상 같아야 한다.

패러티 (parity)  :
데이터의 손실여부를 점검 할 수 있는 데이터 저장체

striped + parity (오류 검출)
parity wiki - 홀수, 짝수 패러티 crc, checksum이 패러티의 개념이다.

Raid 방식

하드웨어 방식 :
하드웨어 자체에 raid를 구축한다.    /    하드웨어는 소프트웨어보다 속도가 훨씬 빠르지만 가격이 비싸다.
메인보드 칩셋에 따라 지원되는 raid level이 다르고 지원을 안하는 제품도 있다.
raid control이라는 제품을 사용하여 확장 할 수 있다.
서버용 메인보드는 보통 raid를 지원한다.


소프트웨어 방식 :
LVM 소프트웨어에서 구성하는 방식이다.    /    유닉스, 리눅스 모두 다  LVM을 지원한다.


디스크를 묶는 방식에 대해서 riad 레벨이 존재한다

raid 0 :
현재는 striped 라는 별명을 갖고 있다.    /    옛날에는 concatenated = span vol = jbod  라고 했다.

raid 0 (striped) :
데이터를 쓸 때 가로로 묶는다.
쓰거나 읽는게 빠르며 동시에 쓰면서 읽을 수 있다. 속도를 높이기 위한 목적으로 사용한다
용량과 퍼포먼스 측면에서 가장 좋은 방식이다.    /    장애처리가 안된다. 

raid 0은 치명적인 문제가 있는데 (disk fault) 파일 시스템이나 디스크가 깨지거나 문제가 생기면 아무 데이터에도 접근을 못하게 된다.

raid 1 (mirror) :
2 way mirror 2개의 디스크를 동시에 저장하는 방식
하나의 디스크만 멀쩡하면 데이터를 온전하게 보존 할 수 있다.

raid도 최악이다.

2개를 해도 하나의 용량밖에 못 쓴다.     /    하지만 장애처리는 제일 좋다.
쓰기 속도는 하나만 쓸 때 보다 똑같거나, 안 좋아질 가능성이 존재한다. 읽기속도는 빨라진다.

riad 2 striped bit
riad 3 striped byte
riad 4 striped block

위에 3개는 사용하지 않는다. 디스크가 2개 이상 있어야한다.
데이터를 striped로 1개 parity 1개 디스크 1개 총 3개의 디스크가 필요하다.
xor 연산 방식이라서 장비 하나가 고장나도 데이터를 온전하게 보존 할 수 있다.
디스크를 3개 사용하게 되면 효율이 3분의 2가 된다.

RAID 2,3,4.    Dedicated Parity Disk     패리티 저장 장치를 하나를 두고 전용으로

riad 5 :
기본적으로 디스크를 데이터로 2개 패러티로 1개 사용한다. 패러티를 분산해서 저장하는 방식을 사용한다.
디스크 하나를 패러티로 소모한다. 하나만 고장 났을 때는 복구가 가능하다. 두 개 이상 고장나면 복구 할 수 없다.

2,3,4 방식과 무슨 차이가 있나?

장애가 났을 때 훨씬 이점이 있다. 확률적으로 3분의 1에 대한 데이터를 계산하지 않아도된다.
분산해서 저장하는게 효율이 더 좋기 때문에 위에 방식을 사용할 이유가 없다.

riad 6 :
데이터 3개 패러티2개를 저장한다. 디스크가 최소 5개 있어야한다. 디스크가 2개 고장나는거 까지 허용이된다.    /    잘 안쓰는 방식

RAID 5,6    Distributed Parity Disk     패리티 저장을 데이터 디스크와 구분하지 않고 분산저장

결론 standard 에선 0, 1, 5만 사용한다.
0은 성능위주 (디스크 하나만 장애가 나면 모두 장애가 난 것과 같다)
1번은 데이터 손실 성능을 어느정도 높이면서 고장을 허용 하는 단계

FT 지원. (장애 극복) 무정지라고도 한다.
장비가 하나 고장이 나도 정상작동, 두개까지 고장이나도 정상작동.. (장애극복)

Nested (하이브리드)
1+0 = 10    /     복합적으로 사용한다.

raid 0+1 :
디스크 4개가 필요하고, 디스크 2개씩 striped, mirror를 한다.

평소에는 2개가 아무 차이가 없다. 공간 효율성은 50% 읽기성능은 striped 한만큼 좋아진다.
1개 일수도 있고 최대 2개까지 장애가 나도 복구 할 수 있다.
볼륨 하나가 죽으면 같이 죽은것과 같아서 (영향을 받는다) 핫 플러그인 방식이라 새거를 꽂으면된다.
새디스크를 꽂으면 데이터를 채워놓는다. 고장이 나서 교체를 하면 4개 동시에 IO가 이루어져서 리소스 소모가 심하다.

raid 1+0
공간 효율성,  성능은 0+1과 같다.
근데 장애가 났을 때 장비를 교체 하면 0+1 방식에 비해 일을 덜한다.
하이브리드 중에는 굳이 쓰려면 1+0 방식을 사용한다.

xor(베타적논리합) 연산을 사용한다.    /    같으면 0 다르면 1 어떤 값이 지워지더라도 계산으로 복구 해낼 수 있다.

100%FREE (100%를 다 사용한다는 의미)
Non-standard levels (비표준 레벨)

Non-raid  :
디스크를 단순하게 묶어 놓은 것 (jbod = 논리 볼륨 만든거와 유사하다)
선형적으로 쓰는 방식 , 단순하게 큰 볼륨을 만드는 목적 밖에 없다.

씬 프로비저닝

Thick
                proision
Thin

스토리지 관련 기술, 실제로는 사용하고 있는 만큼만 할당하는 방식    /    가상화에서 사용하는 기술이다.
특정 임계치에 도달하면 미리 예측을 해서 부족한 만큼 다시 볼륨 사이즈를 증가 시켜야한다.    (부족하면 구매해서 보유)
가상화에서 중요한 개념이다.

물리 볼륨    ->    볼륨 그룹    -> 씬 풀    -> 논리 볼륨 단계로 씬 풀 생성 단계가 추가 된다.

lvcreate -T(씬풀 생성) -V(virtualsize)

VG    50G    /    LV 10 : 100G
Overcommitment, Overcomit 넘는걸 허용한다.
실제 가지고 있는 데이터 보다 오바해서 표현하는걸 허용한다.

볼륨 그룹 확장
vgextend [볼륨이름] [장치] (명령어 방식)

볼륨 그룹 축소
vgreduce [볼륨그룹이름] [장치]

볼륨 축소는 확장과 달리 사용 중이면 여분의 물리 볼륨에 데이터를 옮겨야한다.    /    (pvmove)

pvmove [장치]    /    자기 장치의 볼륨을 쓰면 된다.
하나의 pv라도 남아있으면 해제가 불가능하다.

보통 기업에서는 사내 방침에 따라 고장이 나기전에 교체를 한다.
교체를 하려면 pvmove로 데이터를 옮겨야한다.

논리 볼륨 확장
lvxtend [옵션] [논리적볼륨경로]
    - r : 옵션을 사용하면 파일시스템을 몰라도 자동으로 적용시켜준다.

os가 있는 디스크가 pool이 되면 시스템이 종료가된다.   =>    필요없는  파일을 지워야한다. (용량 확보)
os는 볼륨으로  되어 있는데, 만약 os, root 데이터가 부족하면 볼륨 그룹을 확장 해줄 수 있다.

논리적 볼륨을 확장 할 때 lv를 먼저 늘리고 파일 시스템을 늘려야한다.
실제 존재하지 않는 공간을 데이터로 쓰려면 오류가 뜬다.
파일 시스템에 따라 command가 다르다.

확장할 때
+기호를 쓰고 원하는 데이터를 입력 하면된다.
숫자만 쓰면 그 숫자로 만든다 (- 개념)

xfs_growfs [mount-point]    ->    xfs
resize2fs [logical-volume-path]    ->    ext4

논리 볼륨 축소    /    볼륨 축소는 안하는게 좋다. 볼륨이 깨지는 경우가 많고 실제로 축소는 안한다.
lvreduce [옵션] [logicalvolume-path]
    -r 옵션을 사용하면 파일시스템을 몰라도 자동으로 적용시켜준다.
    사용하는 용량 중 안 쓰는 것? 사용하지 않는 것을 축소

resize2fs [logical-volume-path] size
               [장치]                          [줄일 사이즈]

확장과는 달리 축소할 때는 파일시스템 사이즈를 지정해야한다.
EXT4 파일 시스템만 축소가 가능한데, 볼륨 자체가 깨질 수 있어서 권장하지 않는다.    /    실제로도 안 쓴다.
XFS 파일 시스템은 줄이는 기능 자체가 존재하지 않는다.

자꾸 까먹는 명령어

blkid : 파일시스템 보는 명령어
df -th : 파일 시스템 디스크 공간 확인 명령어     	/     -t 보여주는 파일 시스템 type으로 제한 -h : 1000단위 용량으로 표시