16DAY

사용자 및 그룹 관리

사용자가 만들고 그룹 만들고 관리하고 패스워드를 줄 수 있으면 된다.
시스템은 혼자 쓰는게 아니라 여러 관리자나 실제 접속하는 사용자 뿐 아니라 소프트웨어가 동작 하는데도 특정 계정이 필요하다.
모든 걸 다 관리자로 실행이 가능하다. 하지만 관리자의 권한이 필요하지 않는건 일반 사용자로 작업을 하는게 보안 상 좋다.

사용자를 생성하고, 관리 할 수 있으면 된다.    -> 우리의 최종적 목적
책 하면서 얘기는 많이 하지만, 명령어는 별거 없다. = 이론 베이스가 되야 알고 명령어를 사용한다.

UID : 
사용자(user)는 실제로 시스템을 사용하려는 사람과 연결된 계정이다.
일반적으로 사람들이계정을 쉽게 사용할 수 있도록 사용자 이름을 사용하지만,
시스템은 사용자를 판별 할 때, 이름이 아닌 UID(User ID)라는 사용자 번호로 확인한다.

UID 가같으면 시스템은 같은 사용자로 인식한다. UID를 중복하여 할당하는 경우, 보안상 문제도 있고,
다른 여러 문제가 생길 수 있으니 중복으로 할당하지말자.

GID :
공통의 목적을 가진 사람들이 모인 집합으로 파일의 권한을 공유할 때 사용된다.

그룹
주    /    기본 그룹 (primary)
보조 그룹 (secondary)

사용자는 무조건 하나의 그룹에 속해야한다.
사용자는 자기 자신이고, 그룹은 여기에 있는 주 그룹.

결과적으로 사용자를 생성하면 사용자 이름과 똑같은 그룹이 생성이 되고, 거기에 속하게된다.
주그룹은 무조건 하나에만 속하게된다.
반드시 무조건 주그룹이 하나만 존재 할 수 있다.

보조 그룹
사용자를 설정을 할 때 따로 설정을 하지 않으면 없을 수 있다.
중요한건 파일이나 디렉토리를 생성할 때 소유 그룹은 주 그룹이다.

사용자 그룹 파일
/etc/passwd :
시스템에 등록된 사용자 번호 (이름이 패스워드인데, 패스워드 관련된 내용이 없다)    /    누구든지 읽을 수 있다.
passwd 파일은 총 7개의 필드로 사용자의 정보를 저장하고, 필드는 콜론(:)으로 구분한다.

명령어를 통해서만 변경한다.    /    계정이 많은 이유 : 시스템 커널이 사용한다.    / 로그인 할 때 사용하는 계정이 아니면 건들지말자.
990번 이하 계정은 건들면 안된다. 60000번 이상도 건들면 안된다. (예외 하나 65534 nobody)

user:x:1000:1000:user:/home/user:/bin/bash    =    USER : x : UID : GID : GECOS : HOME : SHELL

user : 계정 이름을 나타낸다. 
x : place holder (비어있는 공간 / 옛날엔 패스워드가 들어갔었다)    
1000 : UID
1000  : primary group id (기본그룹)
user : gecos (주석필드, 계정에 대한 주석 기재가 가능하다)
/home/user : 계정의 홈 디렉토리를 나타낸다. 
/bin/bash : 사용자가 기본으로 사용할 쉘을 나타낸다. [ login sheel 로그인 할 때 사용하는 계정 (접근하면 안된다 / 변경 x) 로그인 못하게 막는다 ]

/etc/shadow :
시스템에 등록된 사용자의 패스워드와 패스워드에 대한 설정

유닉스가 맨 처음에 shadow가 없었다. passwd에 패스워드가 있었는데, 암호화가 되지 않은 정보로 있었다. 그 당시에는 보안이나 네트워크 연결이 없었다.
패스워드에 대한 값을 해시 함수로 암호화 했다.    /    역으로 풀기 어렵다. 하지만 키가 노출이 되면 암호문은 어처피 다 풀린다.

bin:*:16231:0:99999:7:::    =    USER : HASH : LASTCHANGE : MIN : MAX : WARNING : INACTIVE : EXPIRE : BLANK

bin : 사용자의 이름을 나타낸다.
* : 해시 알고리즘을 사용한 패스워드 저장    /    현재 * 값은 패스워드가 없다는 것이다. (로그인이 안된다)
    윈도우에서 자동로그인 쓰는 사람이 많은데, 패스워드가 없는거다.    /    unix는 패스워드가 없으면 로그인이 안된다.
16231 : 마지막으로 패스워드를 변경한 날짜를 의미    /    1970년 1월 1일부터 1일 더하게 되면 마지막 패스워드 변경 날짜를 확인 할 수 있다. = unixtime
0 : 패스워드 변경 후 최소 사용 기간을 의미
99999 : 패스워드 변경 후 최대 사용기간을 의미한다. 해당 기간이 지나기 전에 패스워드 변경 해야한다.    /    99999라는 건 무한대를 의미한다.
7 : 만료일이 되기 전 사용자에게 경고 메시지를 출력할지 설정 MAX=99999, WARNING=7 이면 패스워드를 사용한지 99992일 되는 날부터 경고 메시지 출력
Inactive : 패스워드가 만료되고 Inactive에 지정된 숫자 안에 패스워드를 변경하지 않으면 계정이 잠금 상태가 된다.    /     유예기간, 영원히 못씀
Expire : 사용자 계정의 만료일을 지정
Blank : 예약된 필드로 사용하지 않는다.

/etc/group :
시트템에 등록된 그룹 정보

user:x:1000:user    /    GROUP : x : GID : MEMBER

user : 그룹이름    /    시스템 내에서 그룹이름은 유일해야한다.
x : x    /    예전에 그룹의 패스워드를 저장했었던 필드
1000 : GID
user : 사용자 목록

/etc/gshadow :
시스템에 등록된 그룹의 패스워드와 패스워드에 대한 설정    =    안쓴다. 절대 안쓴다.

password 분실 시 신원을 확인한 후 휴대폰 인증을 거친다.
등록해놓은 질문을 답한다던지, 이메일 링크를 주고 새 패스워드를 설정하게 해준다. = 패스워드를 풀 수 없기에 새로 사이트를 줘서 설정하는거다.
비밀번호 찾기 시 비밀번호를 알려준다면, 그 사이트는 보안이 제대로 되지도 않고, 하지 않을 가능성이 높다.

명령어
useradd [옵션] user-name : 계정 생성
    user01:!!:18069:0:99999:7:::
    user01의 계정 생성을 하고, /etc/shadow 를 열어서 보게 되면 user01에 대한 값이 !!로 되어 있는데,
    !! : 잠겨있다 라는 의미 잠금 LOCK (보통 패스워드가 없거나 만료되면 LOCK이 된다. 패스워드를 부여해주면 풀린다)
    * : 패스워드가 없다 라는 의미    /    로그인X 비활성화 Disable 상태

    계정을 생성하고 passwd 명령어로 패스워드를 설정 할 수 있다.
    패스워드를 설정을 하면 로그인해서 다시 패스워드를 바꿔야한다.    /    현재 패스워드를 설정한 값을 루트가 알고 있기 때문에.

useradd -D  [옵션] [argument] :
    사용자 생성 시 defult 값    /    바꿀 일 없다. 
              -u : 사용자의 UID를 지정한다.
              -U : 사용자를 생성할 때 사용자와 같은 이름의 그룹을 생성
              -g : 사용자의 기본 그룹을 지정한다.
              -G : 사용자의 보조 그룹을 지정한다.


              -c : 주석 다는 명령어
              -r : UID가 199부터 999인 시스템 계정을 만들 때 사용한다.    /    이렇게 할 이유가 없다. X 안쓴다.
              -p : 지정하면 /etc/passwd 필드에 패스워드 저장 / 안쓴다.             
              -m : 홈 디렉토리가 존재하지 않을 경우 생성 / 기본값이다. 안쓰는 명령어

등 다른 옵션도 있지만 대부분 이렇게 옵션을 줘서 쓸 일이 거의 없을거다.

usermod [옵션] user-name : 변경
    -L : 지정한 사용자를 잠금 상태로 변경한다.
    -U : 지정한 사용자의 잠금 상태를 해제한다.

    이외에 여러 옵션이 있지만 사용 안한다.

userde [옵션] user-name : 삭제
    따로 사용하는 옵션이 없고,    -r :  홈 디렉토리까지 한번에 싹 정리 해준다.

    계정을 삭제하고 ls-n이 안했는데, 숫자로 표시되는 계정은 실제로 존재하지 않는 계정이다.
    1001번 계정이 생성되면 다시 할당을 해주는데, 보안상의 문제가 생길 수 있다.
    그러면 어떻게 지워야하나?    수동으로 지워줘야하는데,    -userdel을 사용할 때 -r 옵션을 같이 쓰면 디렉토리까지 제거해준다.

그룹 생성
groupadd [옵션] group-name
    -g : 그룹 생성 시 그룹의 GID 를 지정    /    자동으로 1000번부터 할당
    -o : 그룹 생성 시 GID 중복을 허용    /    절대로 x 하면 안된다. 제대로 동작 안할 수 있다.
    -r : 그룹 생성 시 시스템 그룹으로 생성    /    만들 이유가 없다.

groupmod [옵션] group-name
    -g : 그룹 GID 변경
    -n : 그룹명을 변경

    -o : 그룹의 GID 중복을 허용    /    안쓴다.
    -P : 그룹의 패스워드 변경    /     쓸 이유 없다. 안쓴다.

groupdel group-name
    옵션이 없다.

/etc/skel
    뼈대를 나타내는 디렉토리 여기에 복사 할 파일을 넣어두면 계정 생성 시 복사가된다.    /    이미 존재하는 계정은 복사 X

결론적으로 계정을 생성 하기 전에 필요한 파일을 넣어두고 맘에 드는 SHELL, 옵션을 넣어두면 새로 생성할 때 따로 세팅을 안해도된다.

/etc/login,.defs
    사용자나 그룹을 생성 할 때 참고하는 기본 값

메일 박스의 위치 설정 (리눅스 오류 메시지를 메일박스로 전송하는데 그 위치 설정)
패스워드 에이징 설정 (패스워드 최대 사용 기간, 최소 사용 기간, 최소 길이, 경고 값 등 설정    /    이미 존재하는 계정에는 해당 사항 x)
UID 설정 (교체 할 일 없다)
그룹 GID 설정
홈 디렉토리 생성 여부 결정 (no로 하면 useradd 사용 시 -m 옵션을 사용해서 지정해야한다)
홈 디렉토리 umask 값 설정
UPG 스키마 사용여부 (user private group    /    사용자 생성할 때 같은 이름의 그룹 생성)
패스워드 설정시 해시 알고리즘 설정 (SHA512 / 제일 강력한 방식으로 기본 설정 되어있다)

passwd 에 대한 팁
! : 무조건 잠긴다.    /    패스워드 쳐도 로그인x
계정을 생성할 때 passwd를 사용해서 설정하는데, 계정에 로그인 하면 root가 모르게 다시 바꿔야한다.
last change 0 으로 설정하면 한번도 바꾼 적 없는 계정을 다시 바꾸라고 한다.    /    비밀번호를 주기적으로 바꿔야 할 때 이렇게 설정하면 계정 로그인 하면서 변경한다.

su와 sudo

su [-] [user-name] :
switch user 사용자를 전환한다는 의미 
우리는 privilege escalation(권한상승) 관리자 권한을 취득 하기 위해서 사용을 하는데, 실제 현업에서는 보안 때문에 root 계정을 절대 사용을 안한다.
passwd를 설정을 안해놔서 아예 막아놓은다.

su를 사용하면 여러 사람이 사용 할 때 같은 패스워드를 공유 해야하고, 그 행위가 위험하다.
작업을 할 때 여러 사용자가 타 사용자의 작업을 건들였을 때 추적이 어렵다. (책임추적성)

뒤에 대시 (-)는 내가 다른 계정으로 이동할 때 -를 붙이지 않으면 내 환경설정을 사용한 채 이동하는 것
-를 붙이게 되면 그 계정으 환경설정으로 변경이 된다.
-를 붙이는게 당연히 환경설정 할 때 문제가 생기지 않으니 대시를 사용하는게 좋다.

sudo :
명령어를 실행할 때만 관리자 권한으로 실행 시켜주는 명령어이다.
su를 사용하면 접속하는 계정의 패스워드를 필요로 하는데, sudo는 자신의 패스워드를 사용한다.
sudo -i : 한번 패스워드를 입력하면 일정시간동안 패스워드를 물어보지 않는다.

/etc/sudoers.d 에서 세팅이 가능하다.

/etc/soduers

설정 방법 USER    MACHINE(전환사용자)    COMMAND

root    ALL=(ALL)    ALL
모든 command sudoers.d

sudo도 같은 파일을 여러 명이서 관리하면 누가 어떤 작업을 한지 알 수 없다. (문제 발생 시에도 알 수 없다)
사용자마다 각자 폴더를 만든다.
test localhost(user)    /sbin/useradd    등으로 설정해서 해당 설정에서만 root 권한을 받아오게  할 수도 있다.
nopasswd : ALL    -    패스워드를 안물어본다    /    간혹 귀찮아서 이렇게 하는 경우가 있다고 한다.

sudo vi etc/souders.d    /    visudo 차이점
visudo는 틀린 부분을 체크 해준다.    /    souders.d를 수정 할 땐 visudo가 용이하다.

클라우드에서도 루트는 passwd 설정을 안한다. 모든 걸 sudo setting으로 한다.

명령어 tip
vi에서 :set nu 줄을 숫자로 표시해준다.
보통 새로운 내용을 추가하면 가장 끝에 추가가 되는데, tail 명령어를 사용하면 보기 편하다.

해시 알고리즘
$6 $f3kzG2WfgA9/QSa9 $SDasdwlfgk23fkzas ...

$필드로 구별

$6 : 해시 알고리즘 종류 구분    /    0 : DES    1 : MD5    2 : Blowfish    5 : SHA-256    6 : SHA-512
$salt 값 : C언어 함수 중 실제로 존재한다. / rainbow attack을 더 어렵게 하기위해 사용
    passwd cracking 한다.    패스워드를 찾아내는 공격
    rainbow table : 패스워드 암호문을 테이블로 미리 작성해서 비교만 해서 값을 찾아내는 공격    /    굉장히 고가이다.
    복잡한 암호문을 해독 하려면 엄청난 시간이 걸리는데, 그걸 미리 테이블로 값을 작성해서 비교만 하면 빠르게 찾을 수 있다.
$salt 값을 이용한 해시암호

해시 알고리즘을 salt 함수를 사용해서 더 풀기 어렵게 만들었다.

패스워드 속성 변경
USER : HASH :LASTCHANGE : MIN : MAX : WARING : INACTIVE : EXPIRE : BLANK

change [옵션] [argument] user-name
    -l : 지정된 사용자의 패스워드 속성
    -d : 지정된 사용자의 마지막으로 패스워드를 변경할 날짜를 수정 / 0으로 바꾸면 강제로 패스워드를 변경해야한다.
    -m : min
    -M : max
    -w : warning
    -I : 패스워드가 면료된 후 추가 기간을 주어 패스워드를 변경할 수 있는 날짜를 수정
    -E : 만료 날짜를 특정 날짜로 지정한다.

폰트가 중요하다 방금 명령어 처럼 l과 대문자 I 가 구분이 안된다.
이거말고도 파이프 라던지 등등 때문에 확실하게 구분이 되는 폰트를 사용해야한다.

확장 권한 & ACL

4 setuid = suid    u+s
2 setgid = sgid    g+s
1 sticky = sticky   o+t

umask _ _ _ _

ls -l `which passwd`    = which 특정 명령어의 위치를 찾는 명령어
-rwsr-xr-x 라고 퍼미션이 되있다.    /    setuid 설정 passwd 를 루트권한으로만 사용한다.
setuid passwd 를 루트 권한으로 사용한다.
setuid root 설정 실행은 모두  root로 실행

setuid :
실행하는 동안 root의 권한이 필요 / 대표적으로 passwd 명령에 사용된다.
Unix는 setUID 목록을 추적해야한다.

setgid :
명령어를 실행 할 때 프로세스의 사용자 그룹이 파일의 사용자 그룹으로 실행된다.
파일보다 디렉토리에 gid를 설정한다.

chown [옵션] [소유자:소유 그룹] [파일]    =    파일의 소유자나  소유그룹을 변경하기 위한 명령어
chgrp [계정] [파일] -> 파일의 사용자 그룹을 변경하는 명령어 -> 안 쓴다. chown으로 다 되니까

sticky :
디렉토리 기타사용자 쓰기 권한을 주면 모두가 지울 수 있다.
공용문서를 올리고, 누구나 수정 할 수 있게 = 그럴 일은 없다.
tmp : 즉 임시로 쓰는데는 자기만 지울 수 있다.
디렉토리에서 자기가 만든 파일은 자기만 지울 수 있어야한다.

wall : 모든터미널 글자를 메시지 전송
tty : 모든 사용자 그룹에 속한다.

                        F                        D
SUID                o                        x
SGID                o                        소유그룹
Sbit                  x                        o

실행권한이 있는 상태에서 실행권한을 줘야한다. -R  한꺼번에 적용 
실행권한이 없는 상태에서 확장권한을 주게되면 대문자로 표기된다.

접근 제어 리스트 (access control list)
특정 사용자, 그룹 권한을 추가로 부여한다.
왜 하는지?    ->    파일을 소유한 사용자와 사용자 그룹을 제외한 사용자와 그룹에게 별도로 권한을 부여하려고 한다.

원래 있던 권한에서 특정사용자, 그룹에게 권한을 더 주거나 제거 할 수 있다.

ms : NTFS, FAT    /    linux : XFS, EXT 등
파티션의 종류는 다양하게 여러가지가 있는데, 파일 시스템에 따라서 acl이 없을 수 있다.

[user@localhost user01]$ 
[user@localhost user01]$ getfacl /home/user01/abc/a
getfacl: Removing leading '/' from absolute path names
# file: home/user01/abc/a
# owner: user    -> 소유자
# group: user    -> 그룹
user::rw-            -> 원래 권한
group::rw-         -> 소유그룹이 받는 권한
other::r--           -> 

이 외에도 mask : umask 반대 읽기만 허용 등이 있다.

[user@localhost user01]$ getfacl /home/user01/test
getfacl: Removing leading '/' from absolute path names
# file: home/user01/test
# owner: user01    -> 소유자
# group: user01    -> 그룹
# flags: -s-
user::rwx                -> 원래권한
group::rwx             -> 소유그룹이 받은 권한
group:user:rwx      -> 소유그룹이 받은 권한
mask::rwx              -> umask의 반대.    /    여기서 rwx 다 허용되었다.
other::r-x               -> 기타 사용자 권한

접근 제어 리스트 적용 유무 확인은 ls -l 했을 때 맨 마지막 값이 + 출력이 되어있으면 적용된거다.

getfacl
파일에 적용된 ACL을 확인하기 위한 명령어

setfacl [옵션] [사용자:권한] [지정할 파일, 디렉토리]
    -m : 추가권한
    -x : 추가로 부여 되어있는 정보 삭제
    -b : 모든 부여 되어있는 정보 삭제
    -rm : 설정되지 않은 디렉토리와 그 아래의 파일도 ACL 설정되지 않았을 때 하위 파일까지 적용

tip vi 특징
파일을 동시에 두 개의 터미널에서 열거나, 파일을 저장하지 않고 종료하면 파일이 깨질 수 있는데
해당 파일에 대해 .으로 된 같은 이름의 파일이 있다면 삭제하고 정상 저장 종료 하면된다.

find / -name passswd 1>a 2> /del/null
cat << A (종료가된다)
find / -name passwd > a 2> &
ps -ef | grep log | tee a

tee = cat이랑 비슷하다. (표준 출력이 화면과 파일로 간다)