14DAY

변수, 함수를 정의하는 파일 (실행순서 / 모두가 존재한다면 마지막에 읽는 게 우선순위가 제일 높다)

etc/profile.d    2
/etc/profile     1
~/.profile        3

---------------
/etc/bashrc          6
~/bashrc              5  (non-login shell    /    터미널 열 때 마다 읽힌다.)
~/.bash_profile    4 (로그인 쉘이 bash일 경우에 해당    /    login shell    /로그인 하면 나오는 쉘, CLI 환경 로그인 등)

로그인 쉘, 로그인 할 때 기본적으로 적용 되어있는 쉘 (따로 지정 하지 않으면, 기본으로 사용한다)
어떤 사용자가 로그인 쉘을 Z쉘을 사용하면 위에 3개의 쉘은 적용되지만 아래 쉘은 적용되지 않는다.

etc 디렉토리, home 디렉토리
etc 디렉토리에 있는 건 모든 사용자가 공통적으로 받는다.    /    대부분 수정하지 않는다 전체적으로 영향을 받기 때문에
home 디렉토리는 특정 사용자만 받는다.    (home 디렉토리는 다른 사용자가 사용 할 수 없다)
    나만 쓸 설정이 필요하다 = home 디렉토리에서 설정한다.

보통 서버는 혼자서 관리하는 일이 드물다. 여러 사람이 접근이 가능하다.
개인적 선호 설정은 개인만 해야지 다른 사용자에게 그 영향이 미치면 안된다.

거의 대부분 홈 디렉토리에 있는 것을 적용하는게 일반적이다.

적용되는 순서가 있다.    /     순서를 알아야된다.
똑같은 변수가 있는데, A라는 변수가 모든 파일에 있다고 생각해보자. A의 값은 다 다르다.
최종적으로 어디에 있는 파일에 A의 값이 될까? -> 제일 마지막 우선순위
마지막에 읽는게 우선순위가 제일 높다.

profile은 쉘에 상관없이 모든 사용자가 받게된다.
bashrc 등은 bash 사용자만 받을 수 있다.    /    bash쉘에서만 사용 할 수 있는 기능만 넣어줘야한다.
etc는 모든 사용자    /    home은 특정 사용자

bin과 usr/bin 관계는 어떤가?
    심볼링링크로 둘은 같다.

리눅스에서 사용 할 수 있는 쉘 4가지
bourne shell
bash shell
tshell
cshell

환경변수 파일, 환경설정 파일
환경을 설정한다. 설정 할때 변수를 선언한다.
어떤 특정 변수는 시스템을 사용함에 따라서 시스템 환경에 영향을 미친다.    /     시스템의 환경변수라고 한다.

env : 시스템에 등록된 변수    /    운영체제가 사용하는 변수 (운영체제의 환경설정을 위한 변수)
    -u 변수를 해제한다.
변수의 이름은 대문자로 되어있다.    왼쪽은 이름    /    오른쪽은 그에 대한 값이다.

user 로그인된 사용자, 히스토리 사이즈, ls color 등

set : 쉘이 사용하는 변수    /    export 를 시키면 os가 사용하는 환경변수가 된다.
 unset 변수 : 변수를 해제한다.

export : 내보내기 / 다른 쉘에서 사용 할 수 있도록 내보낸다.    /    환경변수로 내보내기 한 변수이다.
변수를 export 하게 되면 운영체제에서 사용이 가능하다.    /    다른 쉘에서도  사용 할 수 있다.
    declare = 선언한다는 뜻, 이 변수를 운영체제가 사용 할 수 있게 선언

변수들은 시스템에 영향을 주게된다.
변수마다 조작이 가능한 변수가 있다.    /    ex) ps1
변수를 조정하면 시스템 동작에 영향을 줄 수 있다.

echo $PATH
path의 환경 변수 값을 날리면

path 환경변수
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
path라고 하는 변수의 값, 명령어의 위치를 지정한다.    /    디렉토리 8개가 지정되어있다.
기본적으로 명령어를 찾는 위치이다.  ls 명령어를 사용 할 때 실행파일이 현재 디렉토리에 없다.
즉 시스템은 자동으로 path의 순서대로 찾게된다.

which ls : 명령어에 대한 위치가 나온다.

명령어를 실행하는 방법 2가지 절대경로, 상대경로가 있다.
/~/~/ 명령어    -    절대경로    ./명령어    -    상대경로 등

보통은 명령어를 심볼릭링크를 걸어둔다.    /    모든 사용자가 사용하려면 /etc    |    개인만 사용하려면 /home 밑에 링크를건다.

해당 명령어가 있는 위치를 path 변수에 하나 더 넣어준다.

보통 일반적으로 환경설정을 할 때 여러가지가 있는데,
보통 ps1 변수, path 변수는 개인이 선호하는 방식으로 설정한다.

ps1 generator
시스템을 효율적으로 관리 할 수 있다.    +    자신만의 방식으로 구현, 터미널을 커스터마이징도 할 수 있다.

여러가지 운영체제가 사용 변수    /    쉘이 사용하는 변수
ps1, path : 쉘이 사용하는 변수
어플리케이션을 만들거나 외부 어플리케이션을 가지고 왔을 때 요구하는 변수가 있다 -> 어플리케이션 변수
거의 대부분 모양, 설정을 하는 것    /    프로그래밍을 하는 경우는 드물지만, 개념은 알고 있어야한다.

.bashrc를 대부분 이용한다. 이 파일이 홈 디렉토리에 있는 가장 마지막 파일이므로 여기에 설정한다.
ps1 변수
alias (별칭)  : 쉘에 따라 있는 경우도 있고 없는 경우도 있다.    /    긴 명령어, 자주 사용하는 옵션 등을 별칭으로 지정 가능하다.
재부팅, 다른 쉘에 가면 없어지는데, bashrc에서 변수 선언을 해서 저장을 하면된다.

vi랑 vim 명령어가 따로 있다.

login shell : 로그인이 되었을 때 쉘 실행 (CLI 로그인)
non-login shell : 로그인이 되지 않았을 때도 쉘 실행, 터미널 열면 바로 적용 (비로그인 방식)

bash_profile - 로그인 했을 때만 읽게되는 파일이다. 로그아웃을 했다가 다시 로그인을 해야한다.    /    비로그인을 하면 쉘을 안읽는다.
.    ./.bashrc : bashrc를 실행해라 = source .bashrc (같은 명령어)

보통 블로그에선 login shell에 넣으라고 하고 재부팅을 하라고 하는데, 제대로 알고 해야한다.
데스크탑이야 재부팅 하면 되지만, 서버는 재부팅을 하면 안된다.

명령어, 반복문, 조건문 다 쉘 스크립트이다.
시스템 부팅 했을 때, 로그인 했을 때, 쉘 띄웠을 때 자동으로 읽어서 실행한다.

여기 있는 파일 전체가 뭐냐? -> 쉘 스크립트 파일이다.

CHAPTER7 퍼미션

Identification :
식별    /    흔히 말하는 ID
일반적으로 시스템에는 계정  ACOUNT, USER, ID 다 같은 의미이다.

Authentication :
인증    /    ID를 갖고 있는 사람이 맞는지 확인하는 작업
여러가지 방식이 있다.    /    가장 일반적으로 사용하는 방식이 password이다.
password = 고급지게 말하면 지식기반의 인증
생체인식, 지문인식, 얼굴인식 = 소유기반의 인증
요즘은 멀티팩트 인증    |    투팩트 인증    여러가지를 섞어쓴다.
password는 가장 낮은 기반의 인증이 -> 노출 되기가 쉽다.

Credertial :
자격증명    /    자격을 증명하는 방식이 password냐, 생체인식 인증이냐 등

Authorization :
권한부여 & 인가    /    인증을 받게되면 식별이 가능한 ID 기준으로 정책을 만들어놓는데
이런 정책들은 크게 두 가지로 나뉘어진다.

privilege(특권)    /    Rights(권한)
what to do ? 액션
시스템을 끌 수 있느냐?    /    시간을 바꿀 수 있느냐 등의 액션의 개념
user란 사용자가 운영체제를 설치할 때 관리자 권한이 없는 걸 말한다.
일반 사용자는 원래 컴퓨터를 끌 수 없다.    /    일반 사용자는 권한이 없다.

명령어를 사용하는거랑 시스템을 실제로 끌 수 있는거랑 아무 상관 없다.
명령어를 실행 할 수 있어도 컴퓨터를 실제로 끌 수 없을 수 있다.

뭔가를 할 수 있냐 없냐 액션을 취하는 걸 허용하는 것    /    행동에 제한이 걸려있다.

Permission(권한)
How    /what to use?    사용

오브젝트 파일을 사용 할 수 있느냐 없느냐의 개념.

운영체제 접근 방식은 3가지

DAC : 임의적 접근제어
RBAC : 역할기반의 접근제어
MAC : 강제적 접근제어

상업적인 운영체제 = 우리가 사용하는 모든 운영체제 = DAC를 사용한다.
치명적인 문제가 있는데 관리자라는 녀석이 모든 특권을 다 가지고 있다.
일반 사용자는 모든 액션이 제한 걸려 있지만, 관리자는 모두 다 가능한 형태
퍼미션보다 privileg가 더 큰 권한    /    root는 퍼미션 제약을 받지 않는다.    =    신, super user
관리자 계정에 문제가 생기면 게임 끝

가장 기본적인 형태를 안 지키면 보안에 문제가 생긴다.

-               rw-                r--                r--
file type   user              group          other

r = readable 읽기
w = writeable 쓰기
x = executable 실행
- = denied

소유자    ->    그룹    ->    기타사용자로 우선순위가 있으며,
사용자는 무조건 하나의 그룹에 속해야한다.
같은 사용자라면 소유자 비교를해서 접근제어,
그룹, 소유 그룹 접근제어, 나머지는 기타 사용자로 접근제어를 받는다.

파일 퍼미션
읽기 r : 파일의 내용을 확인하거나 복사할 수 있다.    /    cat,    vi,    mv,    cp 등이 가능하다.

쓰기 w : 파일의 내용을 수정할 수 있다.    /    권한이 없으면 파일 생성이 안되고, 만드는 개념, 저장 등이 안된다.

실행 x : 실행파일의 경우 실행할 수 있다.    /    쉘 스크립트 파일의 경우 읽기와 실행 퍼미션을 가지고 있다면 실행 할 수 있다.

읽기와 실행은 짝으로 묶어서 사용한다. -> 쓰기 권한도 필요할까? -> 악성코드를 넣을 수도 있어서 안된다.

Language는 compile, script로 나뉘는데,
compile (exe, elf)    |    script    (shell) 실행권한 x 읽기만한다. 필요에 따라 바뀔 수 있다.
스크립트는 바로 실행이 가능하다. 하지만 직접스크립트는 실행권을 줘야한다.

디렉토리 퍼미션
디렉토리는 파일의 목록을 갖고 있다고 할 수 있다.

읽기 r : ls 명령어를 이용하여 디렉토리 내용을 확인 할 수 있다.

쓰기  w : 실행권한이 있을 경우 디렉토리 내에 파일을 추가하거나 삭제할 수 있다.
    디렉토리 쓰기 권한이 없으면 파일에 권한이 있어도 디렉토리에 대한 권한이 없으므로 파일 추가, 수정, 삭제가 불가능하다.

실행 x : cd 명령어를 이용하여 디렉토리 접근 할 수 있다.    /    읽기 권한이 있다면 ls-l로 디렉토리 내용 확인이 가능함
    읽기 권한이 없다면, 접속은 가능한데 안에 파일은 못 본다.

보통 아주 특수한 목적이 없다면 읽기, 실행 권한에 대한 퍼미션을 준다.
디렉토리는 파일명과 inode와 매핑이 되어있다. = 하드링크이다.

Least privilege : 최소한의 권한    /    데이터 및 기능 오류, 악의적인 동작 (컴퓨터보안) 을 하기 위함이다. 
    중요 디렉토리 내용은 바꾸면 시스템 문제 생기니 바꾸지 말자

Fc (full control) : rwx 모두 권한이 있는 상태를 fc라고 한다.

ls -n :
UID(user in-denfitication number) / GID(group identification number)
소유자의 정보 ID를 확인하기 위한 명령어

1. user 아이디가 접근하려는 사용자의 user ID와 같은지 비교
2. 그룹에 매칭되면 그룹으로 권한을 부여
3. 이도저도아니면 다른 사용자(other)로 권한 부여

퍼미션모드는 심볼릭 모드와 8진수 모드로 나누어지는데, 편한 방식으로 사용하면된다.

심볼릭 모드의 변경

$ chmod        mode        filename 
           who       op       permission(s)

who - u : 소유자    g : 그룹    o : 기타    a : 모든 사용자
op - + : 퍼미션 추가    - : 퍼미션 삭제    = : 퍼미션 추가
permission - r : Read    w : Write    x : Execute // 안 주는 것은 거부

Unix 기본 퍼미션 설정 :
Diretory 777
file 666

umask로 deflut 값이 조정된다.
user    002        /        root    022

관리자 생성파일은 뭐든 그룹에 권한을 주지 않는다.    (필요에 따라 조절가능)
bash 지정 기본 값

서버는 보통 027으로 기본값을 정해놓는다.    /    기타 사용자는 사용하지 못하게한다.

Unix 커널은
user ID = 0 = 관리자 (root)    /    unix도 보통 0이 관리자다.
windows는 adminstrator group = 관리자    /    윈도우는 admin 그룹에 속해있다면 관리자가 된다.

CPU 소켓의 종류
1151v2
2066
소켓이 다르면 연결 할 수 없어서 못 끼운다.

AMD는 소켓을 한번 정하면 잘 안 바꾼다.        업그레이드에 용이
Intel은 새로운 CPU가 나올 때 마다 바꾼다.      업그레이드를 못한다.

인텔 제온
서버용 CPU
성능이 같더라도 서버용은 데스크탑용보다 가격이 더 비싸다.
2011-v3

context switching
바꿔가면서 동시에 하는 거 처럼 사기치는 형식 ㅋㅋ

소켓타입은 nm로 선이 얇을수록 열이 적게 나고 전기를 덜 먹는다.
현재는 너무 작아 엄청 좋은 현미경으로 봐야 보인다고 한다.

자동차는 수냉쿨러를 사용하는데, 컴퓨터의 서버도 수냉쿨러를 사용해서 열을 식힌다.
자연을 이용해서 바다에 데이터센터를 설치한다던지, 산같은 고지대에 설치해서 CPU온도를 줄이는 방식도 있다고한다.
CPU 온도가 80도를 넘어가면 타니까 온도 관리를 해줘야한다.

CPU 캐시
메모리보다 더 빠른 저장공간이다.
명령어를 처리하기 바로 전에 임시로 저장하는 공간이다.
용량이 보통 데스크탑용은 작은편인데, 서버용은 데스크탑보다 큰 약 30MB정도의 크기이다.

하이퍼스레딩 :
하나의 코어에 쓰레드가 2개  (인텔)    /    멀티쓰레드

보통 1코어 2쓰레드
파워 CPU는 1코어 8개 16개 32개    /    쓰레드

인텔 취약점 이슈
쓰레드가 독자적으로 동작 해야하는데 서로에게 영향을 미친다고한다.
그걸로 인해 아무것도 아닌 프로그램을 갖고 루트권한을 취득이 된다고 한다.
과거에 생산된 CPU에서는 하이퍼쓰레드 기능을 끄라고 권장하는데, 그러면 쓰레드의 기능 이유가 없지않나? 라는 딜레마가 생긴다.
서버 CPU를 전 세계에서 인텔회사 제품을 사용하는데, 타 회사에서 소송을 하게 되서 회사마다 보상을 해주게 되면 인텔이 파산할지도 모른다고 한다.

lscpu - cpu정보를 볼 수 있는 명령어

program : disk에 있는 실행 프로그램
process : memory에 있는 실행프로그램이 올라간다.

1 process - 1 thread
개발자가 프로그래망 할 때 멀티 프로세싱을 할 수 있다.
하나의 프로그램이 실행만 하면 프로세스가 여러 개 뜰 수 있는거다.

멀티프로세스 프로그램도 있고, 멀티스레드 프로그램도 있다.

멀티스레드 프로그램의 단점은
CPU에 물리적 스레드가 많지 않으면 논리적 스레드가 많을 때
병목 현상이 발생 할 수 있는데, 그렇게 되면 성능저하가 올 수 있다.

제일 꼭대기 커널 = 스케줄러    /    모든 프로세스를 조정
프로세스의 이름은 실행하는  이름이다.

terminal이 bash를 실행시키고 bash가 ls를 실행시킨다.
terminal은 bash의 부모프로세스 bash는 ls의 부모프로세스라고 볼 수 있다.

              
                  fork() 
                                      wait----->실행
부모--------------------------------
                |                         |
                |                         | exit ()
자식        -------------------

부모는 fork() 함수를 실행 -> 자식 프로세스를 만드는 것
부모는 fork 동안 wait함수로 동작을 중지하고
자식 프로세스는 fork()라는 함수를 통해 메모리로 올라간다.

자식 프로세스는 exec() 함수를 실행시키고
다 끝나면 자식 프로세스는 exit() 함수를 호출
(exit code, return code 호출 - 0 정상종료    1> 비정상종료)
부모는 waith()을 풀고 다시 실행한다.

echo $?
0
uname -x
echo $?
1

man ls
=)
ls exit code 참조

대신 자식이 백그라운드로 동작하게 하면,
부모가 wait()하지 않고 같이 동작이 가능하다.

ls를 백그라운드로 실행할 일은 거의 없다.
잠시 실행되었다 끝나기 때문에
백그라운드 포그라운드 프로세스 어떻게 할지 잘 파악해라.

서비스 :
시스템 부팅 시에 실행되는 프로그램

데몬프로세스 (Daemon process-> 디먼)    | 중간업자
서비스에서 실행하는 프로세스, 부팅과정 중 자동으로 실행할 프로그램 지정

모든 데몬 프로세스가 d가 붙어있는 것은 아니지만, 많은 데몬 프로세스는 마지막에 d가 붙어있다.
하다보면 구별 할 수 있을거다.

rsyslogd, httpd ~d 등

고아 프로세스 (orphan " ")
종료됩니다 하고 exit 코드를 보내야하는데, 못 보내서 못 없어지는 프로세스 -> 하드웨어를 사용하고 있다는 것이다. = 성능저하
지금은 부모의 부모가 부모를 되줘서 괜찮지만, 예전에는 안되어서 각 각 죽여줘야 했다.

원래 부모가 죽으면 자식도 죽는데, 특수한 경우에 부모가 죽었지만 자식이 안 죽었을 때 생겼었다. (지금은 자동으로 해결한다고 함)

좀비 프로세스 (zombie " ")
죽지도 않고 살지도 않은 프로세스 -> 종료를 했지만 몸만 살아서 좀비처럼 있는 것
문제가 뭐냐 ? -> 역시나 하드웨어를 사용하고 있기에 자원을 갉아먹는다.
얘는 반드시 수동으로 죽여줘야한다.

좀비는 Defunct 라고 표시된다.    /    좀비가 아니더라도 hang이 걸렸다 -> 마찬가지로 강제 종료 해야한다.

ps : 현재 터미널에서 실행되는 프로세스만 보여주는 명령어

TTY란 무엇인가?
Tele Type Wirter : 전신기    /    Tele 멀리 떨어져 있는 Type 타이핑 Wirter
한쪽에서 타자를 치면 다른쪽에서 화면에서 출력을 볼 수 있다.

TTY의 다음버전
최종 단말 장치 : 터미널
OS가 설치지되지 않고 콘솔로만 연결해서 CLI  환경으로 글자만 타이핑 하는 형태

지금은 가상이지만 옛날엔 물리적으로 터미널이 있던 형태이다
가상 장치라서
tty 명령어를 치면
/dev/pts/0 으로 나온다.

pts (pseudo terminal second)
pty (pseudo tty)
가상 터미널 개념, 구분 할 필요는 없다.    / 둘 다 pts, pseudo : 가상의, 가상 이란 의미

/dev/pts/1 에서
echo "hello"  /dev/pts/0 이라고 치면
/dev/pts/0 에서 hello가 출력이 된다.

tty
/dev/tty1
-> 실제 터미널이다. (CLI mode)

버추얼 터미널
Ctrl+Alt+F1    tty1
Ctrl+Alt+F2    tty2
Ctrl+Alt+F3    tty3
Ctrl+Alt+F4    tty4
Ctrl+Alt+F5    tty5
Ctrl+Alt+F6    tty6

예전엔 /tty/console이 유일한 터미널 이였다.
여러 터미널 작업을 하기위해서 만든 게 virtual terminal 이다.

UID : 프로세스의 소유자    /    관리자가 프로세스를 실행하는건 위험하다. | 관리자는 조심해서 사용해야한다.
pstree : pid / 부모자식관계

PPID
0 0    =) 커널이 실행시킨것
TTY ?    =) 커널이 실행시킨것

ps -e 모든 프로세스

pgrep : 프로세스의 목록에서 어떤 부분을 확인하는 것

pgrep - x bash 
-> bash(정확한이름)의 PID를 알려달라.

bash
bash
bash
bash
pstree [PPID]
bash---bash---bash---bash---bash---pstree
csh
pstree [PPID]
bash---bash---bash---bash---bash---csh---pstree
pgrep -x bash

시그널
process와 process가 정보를 주고 받는다.

process <------------> process

1.signal
2.message - IPC (매게체)
   Network

kill -l
시그널별로 정해져있다 (약속)
메시지는 정해져 있는 형태가 아니라 프로그램에서의 약속이라고 한다.

IPC로 메시지를 주고 받을 때 메시지의 형태 등이 정해져 있어야 한다.
시스템이 떨어져 있다면 네트워크로 TCP/IP 통신을 한다. PDU 메시지 생각하면  된다.
같은 시스템 내부이지만 네트워크를 이용할 수도 있다.

시그널은 번호에 따라 해야 할 행동이 정해져 있다고 한다.

시그널 대부분이 프로세스를 종료하세요 라는 시그널이다.
1        SIGHUB        Hang Up (전화끊는다)    프로그램 재실행(초기화)
2        SIGINT         Interrupt (Ctrl^C)    프로그램 중단(종료) 인터럽트 신호 / 우선순위가 높다.
9        SIGKILL        Kill(강제종료)
15      SIGTERM     Terminate(정상종료)    프로세스 정상종료(무시가능)

원래는 모뎀에 접속하기 위해 터미널이라는 프로그램이 필요했기 때문에 Hang UP이 있었다.
9번 시그널 빼고는 프로그래머가 무시 할 수 있다.    마음대로 제어가능
1번 시그널 했는데, 재시작 할수도 있고, 종료 될수도 있고, 아무것도 안 할 수도 있다.  | 내가 결정 x

인터럽트는 신호이다.
커널이 여러가지 작업을 막 처리하고 있다가 인터럽트가 들어오면 먼저 처리한다.

TCP flags /URG(긴급) : 위치가 적혀있다.        /        (URG Pointer)
1이 세팅되면 URG Pointer에 뭔가 값이 표시된다.
TCP Header에 데이터가 있고, 긴급한 데이터의 위치가 적혀 있다.
인터럽트가 패킷에 포함되어 가기 때문에 해당 패킷을 먼저 처리해준다.
ctrl c를 하면 URG 플래그로 마킹된 패킷이 간다.

kill 프로세스의 시그널을 전송하는 명령어

kill (PID)
pkill (PNAME)

vi로 열면
메모리에 올라간다.

vi로 저장하면 메모리에 있던 데이터가 디스크로 옮겨가야 한다.
메모리는 가장 빠른 장치이고 디스크는 가장 느린 장치인데,
가장 느린 디스크에 항상 써야 한다고 치면 병목현상이 발생한다.

디스크 어딘가에 기록 해야한다는 것만 기록 해놓고 디스크가 유휴시간이 되면 쓴다고 하는데 실제로 바로바로 반영이 안된다.
메모리에 그대로 있는 경우도 바로 존재한다.

9번 시그널 강제종료

디스크에 반영되지 않는 것이 있으면 15번은 반영하고 종료한다. (정상종료)

15번을 해보고 안죽으면 9번으로  죽이자.
무조건 9번으로 죽이면 시스템에 문제가 생길 가능성도 있다고 한다.

pkill sh
sh 글자 일부라도 검색된다.
프로세스의 패턴을 지정하는 것, 그랩처럼 패턴
일부만 있어도 시그널을 보낸다    /    의도치 않게 전송 될 수 있다.

작업 관리
jobs : 작업 출력 명령어
bg %(작업번호) : 이 작업을 백그라운드에서 동작시키기
fg %(작업번호) : 이 작업을 포그라운드(앞단)에서 동작시키기 (백그라운드에 있던 친구를 불러오는것)
Ctrl^Z :    keyboard stop, 20 SIGTSTP(Signal T stop), 포그라운드에서 작업을 정지하고 정지한 상태로 백그라운드에 넘긴다.
stop %(작업번호) : 백그라운드 작업을 정지시킨다.
 
kill -9 %1

fg %1
